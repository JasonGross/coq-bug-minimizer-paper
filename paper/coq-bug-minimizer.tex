%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan,10pt,review,anonymous]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan]{acmart}\settopmatter{}


%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[PL'18]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2018}{New York, NY, USA}
\acmYear{2018}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\makeatletter
\newcommand{\todo}[1]{%
\@latex@warning{TODO: \detokenize{#1} on page \thepage}%
\textcolor{red}{[\textbf{TODO:} #1]}}%
\makeatother

\begin{document}

%% Title information
\title[Short Title]{Full Title}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
\subtitle{Subtitle}                     %% \subtitle is optional
\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Jason Gross}
\authornote{now with MIRI}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{0000-0002-9427-4891}             %% \orcid is optional
\affiliation{
%  \position{Position1}
  \department{CSAIL}              %% \department is recommended
  \institution{Massachusetts Institute of Technology}            %% \institution is required
  \streetaddress{77 Massachusetts Avenue}
  \city{Cambridge}
  \state{MA}
  \postcode{02139}
  \country{USA}                    %% \country is recommended
}
\email{jgross@mit.edu}          %% \email is recommended

%% Author with two affiliations and emails.
\author{Th√©o Zimmermann}
\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position2a}
  \department{Department2a}             %% \department is recommended
  \institution{Institution2a}           %% \institution is required
  \streetaddress{Street2a Address2a}
  \city{City2a}
  \state{State2a}
  \postcode{Post-Code2a}
  \country{Country2a}                   %% \country is recommended
}
\email{first2.last2@inst2a.com}         %% \email is recommended
\affiliation{
  \position{Position2b}
  \department{Department2b}             %% \department is recommended
  \institution{Institution2b}           %% \institution is required
  \streetaddress{Street3b Address2b}
  \city{City2b}
  \state{State2b}
  \postcode{Post-Code2b}
  \country{Country2b}                   %% \country is recommended
}
\email{first2.last2@inst2b.org}         %% \email is recommended

\author{Adam Chlipala}
%\authornote{with author1 note}          %% \authornote is optional;
%                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position1}
  \department{CSAIL}              %% \department is recommended
  \institution{Massachusetts Institute of Technology}            %% \institution is required
  \streetaddress{77 Massachusetts Avenue}
  \city{Cambridge}
  \state{MA}
  \postcode{02139}
  \country{USA}                    %% \country is recommended
}
\email{adamc@csail.mit.edu}          %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Text of abstract \ldots.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{keyword1, keyword2, keyword3}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

Text of paper \ldots

\section{Improving the coverage of Coq's test-suite}

\subsection{Context and objectives}

Shipping new releases of a compiler frequently can be a challenge
because catching regressions is not trivial, even with an extensive
test suite.
%
This is why, the Rust compiler, for instance, is tested not only on a
large test suite, but also on all the external Rust source code
available on GitHub.\footnote{As narrated by Pietro Albini in his talk
``Shipping a compiler every six weeks'', available at
\url{https://www.youtube.com/watch?v=As1gXp5kX1M} and whose transcript
is available at
\url{https://www.pietroalbini.org/blog/shipping-a-compiler-every-six-weeks/}.}

In the case of the Coq proof assistant, the development team decided
to shorten the release cycles not to six weeks but to six months, but
this still represented a significant challenge to do so reliably.
%
Therefore, in early 2017, they adopted a ``reverse'' continuous
integration, i.e., a continous integration configuration including a
large portion of compatibility testing with external Coq projects (Coq
projects maintained by different teams in different
repositories)~\cite{zimmermann:tel-02451322}.

This continuous testing of external Coq projects represents in itself
a continuous challenge because of the specificities of Coq's
evolution.
%
Indeed, as of today, Coq's evolution still includes many breaking
changes in each release (breaking changes that are evaluated,
validated and documented, and therefore cannot be classified as
regressions, but still break some of the tested projects).
%
Every time such breaking changes are introduced, Coq developers must
fix the tested projects for compatibility, because they would not be
usable for testing anymore if that was not done.
%
Furthermore, fixing external projects can help Coq developers assess
in more depth the practical impact of a breaking change.

A rough assessment shows that more than half of the time that a change
to Coq breaks at least one external tested project, the Coq test suite
still passes fully~\cite{zimmermann:tel-02451322}.
%
We interpret this as insufficient coverage of the Coq test suite with
respect to the features that are actually relied on by users.
%
Therefore, a primary objective of this work was to help improve the
coverage of the test suite by systematically extracting a minimal
reproducible example from any compatibility issue detected while
testing a change to Coq.

A secondary objective was to help Coq developers assess more easily
the kind of compatibility issues that they introduce with their
changes.
%
Indeed, every change to Coq is tested against millions of lines of
externally maintained Coq code.
%
Some of the tested projects can be difficult to navigate and
understand for Coq developers.
%
Therefore, extracting a minimal reproducible example of a
compatibility issue can help the developer to determine whether it is
a regression or a desirable change and therefore to decide whether to
fix the change to Coq or the tested project for compatibility.

\subsection{Technology}

\subsubsection{Extending the bot of the Coq development team with a CI minimization feature}

\subsubsection{Adapting the bug minimizer for minimizing compatibility issues}

\subsubsection{Using GitHub Actions to run the bot}

\subsection{Evaluation}

\section{How the bug minimizer works}
Broadly, the bug minimizer is an adaptation of delta-debugging for Coq developments.

\subsection{The Spec}
The bug minimizer runs a given development through Coq and parses the error message.
The goal is to construct a smaller, more self-contained script that generates the same error message.
An additional constraint that we place on the minimizer is that the proof script generating the error message should be left untouched.
This allows users to write proof scripts such as
\begin{verbatim}
some_tactic;
let G := match goal with |- ?G => G end in
lazymatch G with
| buggy_goal => fail 0 "bug remains"
| _ => fail 0 "bug disappeared!" G
end.
\end{verbatim}
to customize the desired reproducing case, and the minimizer will not decide that it can minimize the entire file to something silly like \verb|Goal False. fail 0 "bug remains"|.

For CI minimization, we furthermore want to preserve the lack of error message on one version of Coq while preserving the error message on the more recent, proposed version of Coq.

\subsection{Control Flow}
Bug minimizer execution has a couple of steps.
We include here the steps that are performed by external scripts for CI minimization.

Steps before the bug minimizer is invoked:
\begin{enumerate}
\item Unpack and install both the succeeding and failing versions of Coq and corresponding developments.
\item Replace the Coq binaries with wrappers that print out the arguments that Coq was called with, as well as COQPATH and pwd.
  \todo{Maybe add text somewhere that I (Jason) think this is a pretty cool way of not having to deal with varied build systems of CI developments.
    Note that there are a bunch of subtleties here: if we don't get access to COQPATH, we won't be able to build some developments.
    If we don't print out the pwd, we can find the right bug file by absolutizing the arguments to coq, but this breaks output tests, cf https://github.com/math-comp/hierarchy-builder/issues/256.}
\item Run Coq on the succeeding and failing developments, ensuring that the version that should pass does in fact pass, and the version that should fail has a recognizable error message.
\item Parse the build log to determine the buggy file name and the arguments to pass to Coq.
  This workflow means that we don't need to directly interface with the varied build systems of various contributions on the CI.
\end{enumerate}

Control flow of the bug minimizer:
\begin{enumerate}
\item Run Coq on the buggy file.
\item Parse the error message, ensuring that it matches with the error message from the build log.
  (Note that there are a bunch of error message changes that we allow, such as changing evar numbers and universe numbers, etc.)
\item Repeat the following steps until a fixed point is reached, skipping any steps that change the error message in a forbidden way.
\begin{enumerate}
\item Remove comments, inserting a header comment with metadata about minimization statistics.
\item Insert a further header which defines the \verb|admit| tactic.
  We must define this tactic ourselves to handle files which build with a non-standard standard library (such as HoTT) and hence don't have access to \verb|Coq.Compat.AdmitAxiom|.
  To support multiple versions of Coq, we need to feature-test Coq to see what fragment of code grants us access to Ltac without loading the standard library; this feature-test is done once and for all for a single run of the bug minimizer.
\item Split \verb|Require| statements from \verb|Import|/\verb|Export|, disambiguating the statements at the same time.
  (If we don't disambiguate them, the \verb|Import|s might point to the wrong module.)
\item Move the \verb|Require| statements to the top of the file, transitively closing them (this allows us to remove \verb|Require| statements which are only needed to transitively require other files).
\item Parse the file into statements (with exactly two exceptions, statements in Coq end with \verb|.| or \verb|...| followed by whitespace; the exceptions are \verb|{| and \verb|}|).
  Note that this is complicated by needing to handle strings which contain a full stop followed by whitespace, and by the fact that comments in Coq are well-balanced and nestable and can contain strings which themselves contain comment identifiers without nesting further comments.
\item Remove statements after the line which generates the error.
\item Split the statements into structured blocks, one per definition/proof.
  We should not assume that we can remove lines from the end of a proof without breaking things, so we treat each theorem/lemma/definition block, combined with its proof, as a unit.
  This is made simpler by the fact that Coq strongly discourages nested proofs, and by the fact that Coq generally forces definitions and their bodies to be side-by-side.
  There are a couple of exceptions to this strategy, that have dedicated passes for handling them:
  \begin{itemize}
  \item \verb|Program| \verb|Definition|s, \verb|Fixpoint|s, etc, have \verb|Obligation| blocks which can be interwoven with other definitions.
    The solution here is to replace such \verb|Obligation| blocks with \verb|Admit Obligations|, which is thankfully a no-op when no obligations are present.
    \todo{Insert some code showing how minimization of program definitions proceeds with admit obligations}
  \item Sections, modules, and module types have paired vernacular delimiters.
    Currently there is some code to eliminate empty blocks, but it doesn't work very well, and misses many cases.
    There's an open feature request for a \verb|Try| vernacular command at https://github.com/coq/coq/issues/15051, which would solve the issue of coupled commands in general.
  \end{itemize}
\item Repeat the following steps until a fixed point is reached (order presented here is not faithful to the minimizer):
  \begin{itemize}
  \item Remove each structured block (whose removal does not change the error message), one at a time, from the end of the file to the beginning of the file.
  \item Replace proof scripts with \verb|Admitted|.
    (There's some nuance about the best ordering strategy to try here, whether to first try all the \verb|Qed| lemmas, whether to first try all lemmas and definitions at once, or whether to just go one at a time in reverse order.)
    Also, we actually replace them with \verb|admit. Defined.| so that previously unfoldable constants remain unfoldable.
    Technically we should try \verb|Admitted| when the proof script previously ended with \verb|Qed| and replacing with \verb|admit. Defined.| fails, because it might be the case that some later tactic relies on this definition not being unfoldable, but we have not encountered such a case yet, and it seems quite unlikely.
  \item Replace \verb|abstract tac| with \verb|admit|, potentially simplifying proof scripts and decreasing dependencies.
  \item Split \verb|Definition foo args : ty := body.| into \verb|Definition foo args : ty.| and \verb|Proof. refine (body). Defined.| so that such definitions can potentially be admitted later.
  \item Replace \verb|Module Foo| with \verb|Module Export Foo|, potentially allowing the removal of \verb|Import| statements later, and potentially eventually allowing the removal of the module itself.
  \item Split \verb|Import| and \verb|Export| statements containing multiple modules into separate statements, so they can be removed separately.
  \item Early on, some likely-to-succeed steps are tried, such as removing tactics, \verb|Variable| and \verb|Context| statements, and definitions which are not referred to at all after their definition.
    This step is superseded by removing each and every structured block one at a time, but may result in faster minimization.
  \end{enumerate}
\item Finally, before repeating the loop, attempt to inline a dependency which has not yet been inlined.
  Inlining dependencies is an interesting technical challenge, due to nuances in how Coq binds names and handles global state.
  \todo{write more text about what's required here, and what still remains}
\end{enumerate}
\end{enumerate}

\subsection{Adaptations specific to Coq}
Coq has a number of quirks that enable efficient bug minimization, as well as a few quirks that seriously hinder bug minimization.
The quirks that enable efficient bug minimization are:
\begin{itemize}
\item lack of forward-references (definitions cannot refer to any identifiers that have not yet been added to the global environment);
\item emitting text files that describe how to hyperlink identifiers, for documentation purposes;
\item ending every comamnd in either one or three full stops, with only two exceptions (\verb|{| and \verb|}|);
\item
\end{itemize}
\subsubsection{Adaptations enabled by lack of forward references}
Because Coq forbids forward references, we can remove all lines after the line where the error occurs without risking a change in error messages.

Additionally, we can, by and large, remove lines in reverse order.
That is, if we removing line $n$ changes the error message, then first removing line $m$ for $m < n$ will almost never result in a success (that is, a lack of error message change) from removing line $n$ later.
This allows us to rely on a single work-horse pass that removes lines, one at a time, starting from the end of the file.

We say ``lines'' above, but in fact a line (a string of characters ended by a newline) is not the natural statement
\subsubsection{Comment Stripping}







Specific adaptations to delta debugging for working with Coq scripts, including
admitting proofs
splitting imports and requires
working in units of "an entire proof script / definition"
being able to work from the end of the file, due to lack of cyclic dependencies (with some minor exceptions, such as program obligations)
the work that it takes to inline one file into another
What specific features (both ones that are already present and ones that are requested) are necessary for producing self-contained single-file test-cases
Integration of delta-debugging into CI failures, in particular:
This is feasible compute-wise (+ some graphs / stats on typical minimization runtime)
We found an interaction mode that seems to work well (+ some feedback on other interaction modes)
(2)
I'm not sure what the overall story for the paper should be ("we did a cool thing, here it is"? or "we did a useful thing, here's what it took and what you need to know if you want to do a similar thing"? or something else?)
Here are some sections that are probably worth including:
What the bug minimizer does (Coq project + error message -> minimal test case) and how it works (delta debugging on maintaining the error message + various details)
How the integration with Coq's CI and GH Actions and coqbot works and what it does (allows PR authors to turn "this failed" into an actually useful test-case that can be further minimized and/or included in the test-suite and/or mined for insight into what changed, maybe note also that this improves on debuggability of error messages --- the error message + source is generally not enough to figure out what's going wrong when the CI fails, Coq doesn't have unit tests because ???, this closes the gap)
Future work including:
Automatic minimization and maintenance of test-cases for bugs reported on Coq's issue tracker
Multi-file minimization
Better support for when bumping the branch targeted by the CI causes a failure (rather than it being a change in Coq)
Various issues that prevent complete inlining of files

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}


\nocite{*}

%% Bibliography
\bibliography{coq-bug-minimizer.bib}


%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots

\end{document}
