id,number,date,body
337520350,3381,2014-06-22 22:51:17,"Do you have a working example test-case?  (If it's in the middle of a large development, you can use my scripts at https://github.com/JasonGross/coq-bug-finder.)  [I don't know the code well enough to look into this, but I'm making test-suite example files.]\nNote that all:eassumption does't backtrack nicely:\nAxioms A B : Type.\nExisting Class A.\nExisting Class B.\nGoal forall (a a' : A) (b b' : B) (H : a = a') (H' : b = b'), exists (a0 : id A) (b0 : id B), a0 = a' /\ b0 = b'.\nintros.\nrefine (ex_intro _ _ (ex_intro _ _ (conj _ _))); unfold id.\nall:eassumption. (* failure *)\nFurthermore, all:typeclasses eauto with core will solve the following goal, which all:eassumption will not:\nAxioms A B : Type.\nExisting Class A.\nExisting Class B.\nGoal forall (a : A, a' : A) (b : B, b' : B) (H : a = a) (H' : b = b), exists (a0 : id A) (b0 : id B), a0 = a' /\ b0 = b'.\nintros."
337520354,3381,2014-06-23 15:43:21,"I will attempt to use your coq-bug-finder to extract a simple test case out of my development.  However, if it doesn't work, my development is housed in github, and I can show how to reproduce this bug with a slight alteration to a case that exists there.\nFirst, I will try your coq-bug-finder...\n-- Jonathan"
337520355,3381,2014-06-23 16:46:29,"The coq-bug-finder crashed with the following error:\n...\nSending statements to coqtop...\nDone.  Splitting to definitions...\nSplitting to definitions unsuccessful.  I will not be able to proceed.  Writing split file to /home/jil/git/mindless-coding/tmptB0ygV.v.\nThe output given was:\nFile ""/tmp/tmpe3gp50.v"", line 581, characters 10-11:\nSyntax error: ',' or ')' expected after [constr:operconstr level 200] (in [constr:operconstr]).\nI think it is very confused by usage of bullets (-+*{}) in proof scripts.  How do you want to proceed, if not as below?:\nThe test case I have without using coq-bug-finder is quite large, but is reproducible.  It is a slight variation on a file I have in my github development https://github.com/jonleivent/mindless-coding.  The file is gaptreeb.v.  If you start with that file, and change the definition of ""insert"" to the following (just the last line changing):\nDefinition insert(x : A){gl gr h f}(t : gaptree gl gr h f)\n: insertResult x h f.\nProof.\nRecurse t = Node gl tl d gr tr [GoLeft|GoRight].\n- Compare x d."
337520361,3381,2014-06-23 17:33:03,"It's getting confused by your ""-intros ..."".  I suspect an off-by-one bug somewhere, which I'll go work on fixing, but in the mean time, if you add spaces after all of your bullets, coq-bug-finder should work fine on your files."
337520362,3381,2014-06-23 17:35:37,"And I meant to submit that comment 15 minutes ago, but it collided with yours and I didn't realize it.  Anyway, I've pushed a change that fixes coq-bug-finder for this case, and it should work for you now.  (I was using gaptree.v.  Oops.)  Let me know if you run in to any other trouble."
337520363,3381,2014-06-23 19:09:51,"Are you set up sufficiently with respect to the typeclasses eauto test case, or do you still need for me to generate that via the fixed coq-bug-finder?"
337520365,3381,2014-06-23 19:13:08,"I'd rather have you generate the file and attach/post it here.  I find that I can often simplify my files further by running coq-bug-finder once on them, then noticing where, e.g., by removing record fields that aren't needed, or knowing arguments that don't need to be carried around everywhere and can be removed.  (And then I'll run coq-bug-finder again.)\nI'm also interested in getting feedback on, and more users of, coq-bug-finder."
337520367,3381,2014-06-23 20:43:55,"test case process by coq-bug-finder\nThe context following the final ""eapply iFitRight."" should match the context described in the first message in this bug report.  From there, the use of typeclasses eauto with core (or, my ""zauto"" tactic, which is almost the same thing) in the first subgoal demonstrates the over-eager solution of evars in all of the other subgoals, to the point where they are no longer solvable.  As is following the ""eapply iFitRight."", all subgoals are solvable by eassumption.\n\nAttached file: stripped_gaptreebug.v (text/x-verilog, 10376 bytes)\nDescription:   test case process by coq-bug-finder"
337520368,3381,2014-09-13 21:16:14,"newer test case processed by coq-bug-finder\n\nAttached file: tceainstbug.v (text/x-verilog, 8918 bytes)\nDescription:   newer test case processed by coq-bug-finder"
337551229,5353,2017-02-12 23:39:03,"(* File reduced by coq-bug-finder from original input, then from 835 lines to \n46 lines, then from 63 lines to 13 lines, then from 1748 lines to 171 lines, \nthen from 531 lines to 194 lines, then from 386 lines to 204 lines, then from \n218 lines to 204 lines, then from 208 lines to 162 lines, then from 176 lines \nto 162 lines, then from 152 lines to 107 lines, then from 121 lines to 107 \nlines, then from 94 lines to 45 lines, then from 59 lines to 45 lines *)\n(* coqc version 8.6 (January 2017) compiled on Jan 23 2017 15:17:5 with OCaml \n4.02.3\n   coqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.6,(HEAD \ndetached from 7e992fa) (cfce4732363c7a93ffb7231335463d4\\n1c47074ea) *)\nRequire Import Coq.Classes.Morphisms Coq.Setoids.Setoid.\nClass Decidable (P : Prop) := dec : {P} + {~P}.\nNotation DecidableRel R := (forall x y, Decidable (R x y)).\nSection Algebra."
337551086,5341,2017-02-08 21:44:57,"(* File reduced by coq-bug-finder from original input, then from 213 linesCoq.Logic.FunctionalExtensionalityunk (February 2017) compiled on Feb 6 2017 16:8:54 with OCaml 4.02.3\n   coqtop version 26-5-163.dynamic.csail.mit.edu:/Users/tchajed/code/sw/coq,trunk (e61e83758e129d455d664b65a1fe15ecac793186), then from 40 lines to 26 lines *)\n(* coqc version trunk (February 2017) compiled on Feb 6 2017 16:8:54 with OCaml 4.02.3\n   coqtop version 26-5-163.dynamic.csail.mit.edu:/Users/tchajed/code/sw/coq,trunk (e61e83758e129d455d664b65a1fe15ecac793186) *)\n\nSet Universe Polymorphism.\n\nSection GenMem.\n  Variable A : Type.\n\n  Theorem upd_nop:  forall (a : A) (x : A) (e : a = x),\n      e = e ->\n      True.\n  Proof.\n    intros."
337551087,5341,2017-02-08 22:26:54,"(* File reduced by coq-bug-finder from original input, then from 490 lines to 38 lines, then from 52 lines to 38 lines *)\n(* coqc version trunk (February 2017) compiled on Feb 6 2017 16:8:54 with OCaml 4.02.3\n   coqtop version 26-5-163.dynamic.csail.mit.edu:/Users/tchajed/code/sw/coq,trunk (e61e83758e129d455d664b65a1fe15ecac793186) *)\n\nSet Universe Polymorphism.\n\nTheorem upd_nop:  forall A (a : A) (x : A) (e : a = x),\n    e = e -> True.\nProof.\n  intros ? ? ? ->.\n  auto.\nQed.\n\nSection GenMem.\n  Variable A : Type."
337543526,4817,2016-06-13 23:04:03,"(* File reduced by coq-bug-finder from original input, then from 341 linCoq.Classes.CMorphismsrom 759 lines to 22 lines, then from 1487 lines to 43 lines, then from 57 lines to 44 lines *)\n(* coqc version 8.5pl1 (June 2016) compiled on Jun 9 2016 17:27:17 with OCaml 4.02.3\n   coqtop version 8.5pl1 (June 2016) *)\nRequire Import Coq.Classes.CMorphisms.\n\nClass Ops A : Type := le : crelation A.\n\nDefinition one_ops : Ops True := fun _ _ => True.\n\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := abstract case proof_admitted.\n\nGoal False.\n  replace ((fun _ _ : True => True) : True -> True -> Type) with (@ le True one_ops).\n  Set Printing All."
337526170,3741,2014-10-15 05:50:29,"(* File reduced by coq-bug-finder from original input, then from 2012 lines to 19 lines *)\n(* coqc version trunk (October 2014) compiled on Oct 11 2014 1:13:41 with OCaml 4.01.0\n   coqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (d65496f09c4b68fa318783e53f9cd6d5c18e1eb7) *)\nRequire Import Coq.Lists.List.\nSection IndexBound.\n\n  Context {A : Set}.\n\n  Class IndexBound (a : A) (Bound : list A) :=\n    { ibound :> nat;\n      boundi : nth_error Bound ibound = Some a}.\n\n  Global Instance IndexBound_tail\n         (a a' : A) (Bound : list A)\n         {sB' : IndexBound a Bound}"
337551072,5340,2017-02-08 21:25:40,"(* File reduced by coq-bug-finder from original input, then from 2702 lines to 29 lines, then from 248 lines to 41 lines, then from 55 lines to 41 lines *)\n(* coqc version trunk (February 2017) compiled on Feb 6 2017 16:8:54 with OCaml 4.02.3\n   coqtop version 26-5-163.dynamic.csail.mit.edu:/Users/tchajed/code/sw/coq,trunk (e61e83758e129d455d664b65a1fe15ecac793186) *)\n\nSet Implicit Arguments.\n\nDefinition EqDec (T : Type) := forall (a b : T), {a = b} + {a <> b}.\n\nPolymorphic Definition mem {A : Type} {AEQ : EqDec A} {V : Type} := A -> option V.\n\nDefinition upd A AEQ V (m : @ mem A AEQ V) (a : A) (v : V) : @ mem A AEQ V :=\n  fun a' => if AEQ a' a then Some v else m a'.\n\nDefinition mem_disjoint AT AEQ V (m1 m2 : @ mem AT AEQ V) :=\n  ~ exists a (v1 v2 : V), m1 a = Some v1 /\ m2 a = Some v2."
337541258,4644,2016-03-23 21:36:46,"(* File reduced by coq-bug-finder from original input, then from 657 lines to 25 lines, then from 1325 lines to 33 lines, then from 495 lines to 49 lines, then from 353 lines to 67 lines, then from 235 lines to 77 lines, then from 1900 lines to 80 lines, then from 94 lines to 80 lines *)\n(* coqc version 8.5 (March 2016) compiled on Mar 21 2016 18:39:8 with OCaml 4.02.3\n   coqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.5,v8.5 (09c2011fbdbb2ac1ce33e5abe52d93b907b21a3c) *)\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := case proof_admitted.\nRequire Export Coq.Classes.Morphisms.\nRequire Import Coq.Lists.List.\n\nGlobal Set Implicit Arguments.\n\nDefinition list_caset A (P : list A -> Type) (N : P nil) (C : forall x xs, P (x::xs))\n           ls\n  : P ls\n  := match ls with\n     | nil => N"
337551199,5351,2017-02-10 04:10:55,"(* File reduced by coq-bug-finder from original input, then from 152 lines to \n58 lines, then from 372 lines to 235 lines, then from 465 lines to 270 lines, \nthen from 490 lines to 287 lines, then from 3279 lines to 311 lines, then from \n324 lines to 311 lines, then from 115 lines to 83 lines, then from 97 lines to \n83 lines, then from 68 lines to 54 lines, then from 68 lines to 54 lines, then \nfrom 35 lines to 22 lines, then from 36 lines to 22 lines *)\n(* coqc version trunk (February 2017) compiled on Feb 9 2017 16:16:58 with \nOCaml 4.04.0\n   coqtop version cauchy.local:/Users/tchajed/code/sw/coq,trunk \n(ebbc4a8cf3dde3b18388f3723b1641ba5511db9b) *)\n\nPolymorphic Inductive T:Type := t.\nPolymorphic Definition general_ok (pre: T -> Prop) := forall v, pre v.\nPolymorphic Definition ok := general_ok (fun _ => True).\n"
337553887,5528,2017-05-16 05:41:18,"(* File reduced by coq-bug-finder from original input, then from 557 lines to \n63 lines, then from 225 lines to 136 lines, then from 247 lines to 162 lines, \nthen from 325 lines to 230 lines, then from 390 lines to 264 lines, then from \n378 lines to 304 lines, then from 537 lines to 318 lines, then from 425 lines \nto 364 lines, then from 549 lines to 380 lines, then from 469 lines to 396 \nlines, then from 533 lines to 415 lines, then from 464 lines to 429 lines, then \nfrom 443 lines to 430 lines, then from 405 lines to 380 lines, then from 374 \nlines to 301 lines, then from 307 lines to 301 lines, then from 251 lines to \n151 lines, then from 157 lines to 151 lines, then from 114 lines to 86 lines, \nthen from 93 lines to 87 lines, then from 78 lines to 46 lines, then from 52 \nlines to 46 lines *)\n(* coqc version 8.6 (May 2017) compiled on May 11 2017 12:23:39 with OCaml \n4.02.3\n   coqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.6,(HEAD \ndetached from 7e992fa) (3b6d89acf4f233d0ed33f89c4e60bcd68e0e2820) *)"
337518178,3254,2014-03-10 08:39:01,"(* File reduced by coq-bug-finder, originally 1957 lines, recently from 185 lines to 174 lines. *)\nRequire Import Coq.Classes.Morphisms Coq.Classes.RelationClasses Coq.Program.Program Coq.Setoids.Setoid.\n\nGlobal Set Implicit Arguments.\n\nReserved Infix ""~>"" (at level 70).\nDelimit Scope bundled_comp_scope with bundled_comp.\nGlobal Open Scope bundled_comp_scope.\n\nClass Context :=\n  { names : Type;\n    dom : names -> Type;\n    cod : names -> Type }.\n\nInductive Comp `{ctx : Context} : Type -> Type :="
337551429,5366,2017-02-21 19:41:30,"( File reduced by coq-bug-finder from original input, then from 204 lines to\n52 lines, then from 434 lines to 321 lines, then from 328 lines to 62 lines,\nthen from 246 lines to 97 lines, then from 348 lines to 149 lines, then from\n276 lines to 201 lines, then from 318 lines to 248 lines, then from 628 lines\nto 568 lines, then from 555 lines to 112 lines, then from 551 lines to 137\nlines, then from 338 lines to 238 lines, then from 430 lines to 242 lines, then\nfrom 256 lines to 242 lines, then from 205 lines to 168 lines, then from 182\nlines to 168 lines, then from 173 lines to 89 lines, then from 103 lines to 89\nlines, then from 100 lines to 47 lines, then from 61 lines to 47 lines, then\nfrom 40 lines to 22 lines, then from 36 lines to 23 lines )\n( coqc version 8.6 (February 2017) compiled on Feb 16 2017 14:36:53 with OCaml\n4.02.3\ncoqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.6,(HEAD\ndetached from 7e992fa) (29d7872) )\nRequire Import Coq.ZArith.BinInt."
337530670,4004,2015-02-06 22:41:46,"(I'm trying to write a python script to automatically implement the suggestions of [Set Suggest Proof Using], currently at https://github.com/JasonGross/coq-bug-finder/blob/master/proof-using-helper.py.)"
337533566,4160,2015-03-25 21:12:38,"(* File reduced by coq-bug-finder from original input, then from 58 lines to 47 lines, then from 40 lines to 30 lines *)\n(* coqc version 8.5beta1 (March 2015) compiled on Mar 15 2015 16:24:54 with OCaml 4.01.0\n   coqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (1b3759e78f227eb85a128c58b8ce8c11509dd8c3) *)\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := case proof_admitted.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nInductive String : Set :=\n| empty : String\n| string (c : bool) (cs : String) : String.\nDefinition head_type (s : String) : Set :=\n  match s with\n  | empty => unit\n  | string _ _ => bool\n  end.\nDefinition head (s : String) : head_type s :="
337518161,3253,2014-03-10 08:32:49,"(* File reduced by coq-bug-finder from 185 lines to 174 lines. *)\nRequire Import Coq.Classes.Morphisms Coq.Classes.RelationClasses Coq.Program.Program Coq.Setoids.Setoid.\n\nGlobal Set Implicit Arguments.\n\nAxiom admit : False.\nLtac admit := abstract destruct admit.\n\nReserved Infix ""~>"" (at level 70).\nDelimit Scope bundled_comp_scope with bundled_comp.\nGlobal Open Scope bundled_comp_scope.\n\nClass Context :=\n  { names : Type;\n    dom : names -> Type;"
337554709,5576,2017-06-03 04:02:39,"( File reduced by coq-bug-finder from original input, then from 1610 lines to\n38 lines, then from 473 lines to 38 lines, then from 106 lines to 38 lines,\nthen from 102 lines to 58 lines, then from 71 lines to 35 lines, then from 49\nlines to 43 lines )\n( coqc version trunk (May 2017) compiled on May 30 2017 13:28:59 with OCaml\n4.02.3\ncoqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-trunk,trunk\n(fd36c04) *)\nRequire Import Coq.FSets.FMapPositive.\nRequire Import Coq.FSets.FMapFacts.\nGoal forall type (P : Set -> Set) (b : forall A : Set, P A -> A -> A -> bool)\n(T : Set -> Type)\n(P0 : forall A : Set, T A -> T A -> Prop)\n(c : forall A B : Set, T B -> (B -> T A) -> T A),\n(forall A : Set, @ Equivalence (T A) (P0 A)) ->"
337529180,3915,2015-01-12 19:42:25,"(* File reduced by coq-bug-finder from original input, then from 2352 lines to 162 lines, then from 138 lines to 50 lines *)\n(* coqc version trunk (January 2015) compiled on Jan 10 2015 10:54:47 with OCaml 4.01.0\n   coqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (b858f939f33dc4bc4c8e470ed62310ef15c59a99) *)\n\nNotation compose g f := (fun x => g (f x)).\nNotation ""g 'o' f"" := (compose g f) (at level 40, left associativity) : function_scope.\nOpen Scope function_scope.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\nArguments idpath {A a} , [A] a.\nNotation ""x = y :> A"" := (@ paths A x y) : type_scope.\nNotation ""x = y"" := (x = y :>_) : type_scope.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with idpath => idpath end.\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A }.\nNotation ""f ^-1"" := (@ equiv_inv _ _ f _) (at level 3, format ""f '^-1'"") : equiv_scope.\nLocal Open Scope equiv_scope."
337526662,3766,2014-10-25 06:06:02,"(* File reduced by coq-bug-finder from original input, then from 7916 lines to 292 lines, then from 258 lines to 43 lines )\n( coqc version trunk (October 2014) compiled on Oct 24 2014 13:2:47 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (9973cd2) )\nNotation ""( x ; y )"" := (existT _ x y).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDelimit Scope path_scope with path.\nNotation ""1"" := idpath : path_scope.\nAxiom ap : forall {A B:Type} (f:A -> B) {x y:A} (p:x = y), f x = f y.\nAxiom dummy_funext_type : Set.\nClass Funext := { dummy_funext_value : dummy_funext_type }.\nRecord Functor := { object_of :> Type -> Type ; identity_of : Type }.\nAxiom path_functor'_sig : forall {Funext} (F G : Functor), { HO : object_of F = object_of G & Set = Set } -> F = G. Axiom path_functor'_sig_fst : forall {Funext} F G HO HM, ap object_of (@ path_functor'_sig _ F G (HO; HM)) = HO.\nGoal forall (H : Funext) (objof : Type -> Type) io1 io2 k,\n(ap object_of"
672988439,12831,2020-08-12 16:46:36,"(* File reduced by coq-bug-finder from original input, then from 91 lines to 22 lines, then from 490 lines to 424 lines, then from 521 lines to 462 lines, then from 515 lines to 8 lines, then from 1052 lines to 962 lines, then from 1000 lines to 996 lines, then from 970 lines to 821 lines, then from 834 lines to 214 lines, then from 215 lines to 142 lines, then from 558 lines to 145 lines, then from 178 lines to 145 lines, then from 555 lines to 207 lines, then from 221 lines to 207 lines, then from 202 lines to 87 lines, then from 101 lines to 87 lines, then from 102 lines to 82 lines, then from 96 lines to 82 lines *)\n(* coqc version 8.10.1 (June 2020) compiled on Jun 1 2020 17:32:00 with OCaml 4.08.1\n   coqtop version 8.10.1 (June 2020) *)\nRequire parseque.Parseque.\nRequire Coq.extraction.Extraction.\n\nSection Host.\n\nDefinition module : Type := nat .\n\nEnd Host.\nImport parseque.Parseque.\nImport Coq.Init.Byte.\n\nNotation ""p $> b"" := (cmap b p) (at level 59, right associativity)."
337551738,5389,2017-03-10 01:52:13,"( File reduced by coq-bug-finder from original input, then from 282 lines to\n108 lines, then from 324 lines to 147 lines, then from 342 lines to 172 lines,\nthen from 226 lines to 187 lines, then from 246 lines to 195 lines, then from\n273 lines to 211 lines, then from 251 lines to 216 lines, then from 265 lines\nto 217 lines, then from 231 lines to 217 lines, then from 233 lines to 109\nlines, then from 123 lines to 109 lines )\n( coqc version 8.6 (February 2017) compiled on Feb 16 2017 14:36:53 with OCaml\n4.02.3\ncoqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.6,(HEAD\ndetached from 7e992fa) (29d7872\n9dc7c90c9) *)\nGlobal Set Asymmetric Patterns.\nSection language.\nContext (base_type_code : Type).\nInductive flat_type := Tbase (T : base_type_code) | Unit | Prod (A B :"
337544381,4868,2016-06-29 15:33:33,"( File reduced by coq-bug-finder from original input, then from 148 lines to 17 lines, then from 57 lines to 16 lines, then from 879 lines to 44 lines, then from 58 lines to 44 lines )\n( coqc version 8.5pl1 (June 2016) compiled on Jun 13 2016 21:7:27 with OCaml 4.02.3\ncoqtop version 8.5pl1 (June 2016) *)\nGlobal Set Universe Polymorphism.\nGlobal Unset Strict Universe Declaration.\nGlobal Unset Universe Minimization ToSet.\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A }.\nInductive Unit : Set := tt : Unit.\nNotation unit_name x := (fun (_ : Unit) => x).\nGlobal Instance isequiv_unit_name@ {i j} (A : Type@ {i})\n: @ IsEquiv@ {i j} _ (Unit -> _) (fun (a:A) => unit_name a).\nAdmitted.\nGlobal Instance isequiv_unit_name'@ {i j} (A : Type@ {i})\n: @ IsEquiv@ {i j} _ _ (fun (a:A) => unit_name a).\nAdmitted."
337522478,3515,2014-08-12 22:12:16,"(* File reduced by coq-bug-finder from original input, then from 5752 lines to 3828 lines, then from 2707 lines to 558 lines, then from 472 lines to 168 lines, then from 110 lines to 101 lines, then from 96 lines to 77 lines *)\nRequire Coq.Setoids.Setoid.\nImport Coq.Setoids.Setoid.\nGeneralizable All Variables.\nAxiom admit : forall {T}, T.\nClass Equiv (A : Type) := equiv : relation A.\nClass type (A : Type) {e : Equiv A} := eq_equiv : Equivalence equiv.\nClass ILogicOps Frm := { lentails: relation Frm;\n                         ltrue: Frm;\n                         land: Frm -> Frm -> Frm;\n                         lor: Frm -> Frm -> Frm }.\nInfix ""|--""  := lentails (at level 79, no associativity).\nInfix ""\\//""   := lor (at level 76, right associativity).\nClass ILogic Frm {ILOps: ILogicOps Frm} := { lentailsPre:> PreOrder lentails }.\nDefinition lequiv `{ILogic Frm} P Q := P |-- Q /\ Q |-- P."
876527016,6623,2021-07-08 15:18:27,"(* File reduced by coq-bug-finder from original input, then from 269 lines to 101 lines, then from 215 lines to 453 lines, then from 457 lines to 194 lines, then from 307 lines to 714 lines, then from 717 lines to 236 lines, then from 343 lines to 529 lines, then from 533 lines to 298 lines, then from 404 lines to 422 lines, then from 426 lines to 297 lines, then from 393 lines to 849 lines, then from 853 lines to 319 lines, then from 415 lines to 866 lines, then from 869 lines to 279 lines, then from 372 lines to 817 lines, then from 820 lines to 282 lines, then from 323 lines to 346 lines, then from 350 lines to 282 lines, then from 319 lines to 1351 lines, then from 1355 lines to 292 lines, then from 320 lines to 454 lines, then from 458 lines to 295 lines, then from 323 lines to 394 lines, then from 398 lines to 297 lines, then from 324 lines to 346 lines, then from 350 lines to 302 lines, then from 326 lines to 409 lines, then from 413 lines to 311 lines, then from 335 lines to 550 lines, then from 553 lines to 337 lines, then from 360 lines to 831 lines, then from 835 lines to 335 lines, then from 354 lines to 1114 lines, then from 1112 lines to 336 lines, then from 354 lines to 486 lines, then from 487 lines to 414 lines, then from 431 lines to 468 lines, then from 472 lines to 424 lines, then from 440 lines to 697 lines, then from 701 lines to 452 lines, then from 467 lines to 699 lines, then from 703 lines to 511 lines, then from 525 lines to 1341 lines, then from 1341 lines to 629 lines, then from 642 lines to 764 lines, then from 768 lines to 643 lines, then from 655 lines to 704 lines, then from 708 lines to 649 lines, then from 660 lines to 960 lines, then from 959 lines to 676 lines, then from 680 lines to 676 lines *)\n(* coqc version 8.13.2 (April 2021) compiled on Apr 3 2021 23:10:57 with OCaml 4.05.0\n   coqtop version 8.13.2 (April 2021) *)\nDeclare ML Module ""ltac_plugin"".\nInductive False := .\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := abstract case proof_admitted.\nGlobal Set Default Proof Mode ""Classic"".\n\nReserved Notation ""x -> y"" (at level 99, right associativity, y at level 200).\nReserved Notation ""~ x"" (at level 35, right associativity).\n\nReserved Notation ""x = y  :>  T""\n(at level 70, y at next level, no associativity).\nReserved Notation ""x = y"" (at level 70, no associativity)."
337526655,3765,2014-10-25 06:03:51,"(* File reduced by coq-bug-finder from original input, then from 7916 lines to 292 lines, then from 258 lines to 43 lines )\n( coqc version trunk (October 2014) compiled on Oct 24 2014 13:2:47 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (9973cd2) *)\nNotation ""( x ; y )"" := (existT _ x y).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDelimit Scope path_scope with path.\nNotation ""1"" := idpath : path_scope.\nAxiom ap : forall {A B:Type} (f:A -> B) {x y:A} (p:x = y), f x = f y.\nAxiom dummy_funext_type : Set.\nClass Funext := { dummy_funext_value : dummy_funext_type }.\nRecord Functor := { object_of :> Type -> Type ; identity_of : Type }.\nModule Foo.\nAxiom path_functor'_sig : forall {Funext} (F G : Functor), { HO : object_of F = object_of G & Set = Set } -> F = G. Axiom path_functor'_sig_fst : forall {Funext} F G HO HM, ap object_of (@ path_functor'_sig _ F G (HO; HM)) = HO.\nGoal forall (H : Funext) (objof : Type -> Type) io1 io2 k,"
337524541,3642,2014-09-18 09:07:56,"(* File reduced by coq-bug-finder from original input, then from 7593 lines to 243 lines, then from 256 lines to 102 lines, then from 104 lines to 28 lines, then from 38 lines to 20 lines )\n( coqc version trunk (September 2014) compiled on Sep 17 2014 0:22:30 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (d34e1ee) )\nSet Implicit Arguments.\nClass UnitSubuniverse := { O : Type -> Type ; O_unit : forall T, T -> O T }.\nClass ReflectiveSubuniverse := { rsubu_usubu : UnitSubuniverse ; O_rectnd : forall {P Q : Type} (f : P -> Q), O P -> Q }.\nGlobal Existing Instance rsubu_usubu.\nContext {subU : ReflectiveSubuniverse}.\nGoal forall (A B : Type) (x : O A * O B) (x0 : B),\n{ g : _ & O_rectnd (fun z : A * B => (O_unit (fst z), O_unit (snd z)))\n(O_rectnd (fun a : A => O_unit (a, x0)) (fst x)) =\ng x0 }.\neexists.\nmatch goal with\n| [ |- context[?e] ] => is_evar e; let e' := fresh ""e'"" in pose (e' := e)"
337524544,3642,2014-09-18 09:10:30,"(* File reduced by coq-bug-finder from original input, then from 7593 lines to 243 lines, then from 256 lines to 102 lines, then from 104 lines to 28 lines, then from 38 lines to 20 lines )\n( coqc version trunk (September 2014) compiled on Sep 17 2014 0:22:30 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (d34e1ee) *)\nSet Implicit Arguments.\nClass UnitSubuniverse := { O : Type -> Type ; O_unit : forall T, T -> O T }.\nClass ReflectiveSubuniverse := { rsubu_usubu : UnitSubuniverse ; O_rectnd : forall {P Q : Type} (f : P -> Q), O P -> Q }.\nGlobal Existing Instance rsubu_usubu.\nContext {subU : ReflectiveSubuniverse}.\nGoal forall (A B : Type) (x : O A * O B) (x0 : B),\n{ g : _ & O_rectnd (fun z : A * B => (O_unit (fst z), O_unit (snd z)))\n(O_rectnd (fun a : A => O_unit (a, x0)) (fst x)) =\ng x0 }.\neexists.\nmatch goal with\n| [ |- context[?e] ] => is_evar e; let e' := fresh ""e'"" in pose (e' := e)"
337526693,3768,2014-10-25 22:58:04,"(* File reduced by coq-bug-finder from original input, then from 7916 lines to 292 lines, then from 476 lines to 306 lines *)\nSet Primitive Projections.\nSet Implicit Arguments.\nRecord sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\nNotation ""{ x : A  & P }"" := (sigT (fun x:A => P)) : type_scope.\nUnset Implicit Arguments.\nNotation ""( x ; y )"" := (existT _ x y).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDelimit Scope path_scope with path.\nNotation ""1"" := idpath : path_scope.\nAxiom ap : forall {A B:Type} (f:A -> B) {x y:A} (p:x = y), f x = f y.\nAxiom dummy_funext_type : Set.\nClass Funext := { dummy_funext_value : dummy_funext_type }.\nRecord Functor := { object_of :> Type -> Type ; identity_of : Type }."
875572414,3738,2021-07-07 12:45:30,"(* File reduced by coq-bug-finder from original input, then from 258 lines to 146 lines, then from 160 lines to 194 lines, then from 198 lines to 153 lines, then from 157 lines to 153 lines *)\n(* coqc version 8.15+alpha compiled with OCaml 4.12.0\n   coqtop version 8.15+alpha *)\nRequire Coq.funind.Recdef.\nRequire Coq.Vectors.Vector.\n\nNotation vec := Vector.t.\nNotation LB := (list bool).\n\nNotation Byte := (vec bool 8).\n\nNotation LByte := (list Byte).\n\nImport Coq.Lists.List.\n"
337521225,3445,2014-07-21 09:39:27,"(* File reduced by coq-bug-finder from original input, then from 7372 lines to 539 lines, then from 529 lines to 94 lines, then from 78 lines to 10 lines *)\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A }.\nNotation ""f ^-1"" := (@ equiv_inv _ _ f _) (at level 3).\nDefinition path_sigma_hprop {A : Type} {P : A -> Type} (u v : sigT P) `{IsEquiv _ _ (@ projT1 A P)}\n  := projT1^-1.\n(* Toplevel input, characters 123-129:\nError:\nIn environment\nA : Type\nP : A -> Type\nu : {x : A & P x}\nv : {x : A & P x}\nH : IsEquiv (projT1 (P:=P))\nThe term ""projT1"" has type\n ""forall (A : Type) (P : A -> Type), {x : A & P x} -> A"""
337534411,4215,2015-04-29 19:17:26,"(* File reduced by coq-bug-finder from original input, then from 196 lines to 185 lines, then from 195 lines to 151 lines *)\n(* coqc version 8.5beta1 (April 2015) compiled on Apr 9 2015 15:39:28 with OCaml 4.01.0\n   coqtop version cagnode13:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (33650e275a4b3f00541ea87ee4b39892be5fdb2f) *)\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := case proof_admitted.\nModule Export Overture.\n\n  Definition relation (A : Type) := A -> A -> Type.\n\n  Class Symmetric {A} (R : relation A) :=\n    symmetry : forall x y, R x y -> R y x.\n  Delimit Scope function_scope with function.\n\n  Notation compose := (fun g f x => g (f x)).\n"
337520860,3419,2014-07-13 11:21:36,"(* File reduced by coq-bug-finder from original input, then from 3442 lines to 40 lines *)\nNotation ""( x ; y )"" := (existT _ x y) : fibration_scope.\nOpen Scope fibration_scope.\nNotation ""x .1"" := (projT1 x) (at level 3) : fibration_scope.\nNotation ""x .2"" := (projT2 x) (at level 3) : fibration_scope.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y :> A"" := (@ paths A x y) : type_scope.\nArguments idpath {A a} , [A] a.\nNotation ""x = y"" := (x = y :>_) : type_scope.\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y :=\n  match p with idpath => u end.\nNotation ""p # x"" := (transport _ p x) (right associativity, at level 65, only parsing) : path_scope.\nLocal Open Scope path_scope.\nDefinition path_sigma_uncurried {A : Type} (P : A -> Type) (u v : sigT P)\n           (pq : {p : u.1 = v.1 &  p # u.2 = v.2})\n: u = v"
623028745,12226,2020-05-02 23:25:40,"(* File reduced by coq-bug-finder from original input, then from 114 lines to 69 lines, then from 303 lines to 142 lines, then from 855 lines to 578 lines, then from 593 lines to 578 lines *)\n(* coqc version 8.11.1 (May 2020) compiled on May 2 2020 21:56:28 with OCaml 4.08.1\n   coqtop version 8.11.1 (May 2020) *)\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := abstract case proof_admitted.\nRequire Equations.Equations.\nRequire Coq.Numbers.Cyclic.Int63.Int63.\nRequire Prelude.Init.\nImport Coq.Setoids.Setoid.\nImport Coq.Strings.String.\nImport Coq.Numbers.Cyclic.Int63.Int63.\nImport Coq.Strings.Byte.\nImport Prelude.Init.\n\nClass Equality (a : Type) :="
623030410,12226,2020-05-02 23:46:59,"(* File reduced by coq-bug-finder from original input, then from 114 lines to 69 lines, then from 303 lines to 142 lines, then from 855 lines to 578 lines, then from 593 lines to 578 lines, then from 321 lines to 200 lines, then from 215 lines to 200 lines, then from 176 lines to 103 lines, then from 117 lines to 104 lines *)\n(* coqc version 8.11.1 (April 2020) compiled on Apr 4 2020 17:41:20 with OCaml 4.06.1\n   coqtop version 8.11.1 (April 2020) *)\nRequire Coq.Numbers.Cyclic.Int63.Int63.\nImport Coq.Setoids.Setoid.\nDeclare Scope prelude_scope.\n#[global] Open Scope prelude_scope.\n#[global] Generalizable All Variables.\nClass Equality (a : Type) := { equal (x y : a) : Prop ; rel :> Equivalence equal }.\nInfix ""=="" := equal (at level 70, no associativity) : prelude_scope.\nInstance list_Equality `(Equality a) : Equality (list a).\nAdmitted.\nModule Export Control.\nSet Universe Polymorphism.\nDefinition compose {a b c} (g : b -> c) (f : a -> b) : a -> c := fun (x: a) => g (f x)."
337549109,5199,2016-11-14 17:09:50,"(* File reduced by coq-bug-finder from original input, then from 286 lines to \n27 lines, then from 224 lines to 53 lines, then from 218 lines to 56 lines, \nthen from 269 lines to 180 lines, then from 132 lines to 48 lines, then from \n253 lines to 65 lines, then from 79 lines to 65 lines *)\n(* coqc version 8.6.0 (November 2016) compiled on Nov 12 2016 14:43:52 with \nOCaml 4.02.3\n   coqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.6,v8.6 \n(7e992fa784ee6fa48af8a2e461385c094985587d) *)\nAxiom admit : forall {T}, T.\nSet Printing Implicit.\nInductive nat := O | S (_ : nat).\nAxiom f : forall (_ _ : nat), nat.\nRecord ZLikeOps (e : nat)\n  := { LargeT : Type ; SmallT : Type ; CarryAdd : forall (_ _ : LargeT), LargeT \n}."
337539345,4525,2016-01-24 06:19:22,"(* File reduced by coq-bug-finder from original input, then from 953 lines to \n170 lines, then from 184 lines to 170 lines, then from 705 lines to 214 lines, \nthen from 228 lines to 214 lines *)\n(* coqc version 8.5 (January 2016) compiled on Jan 23 2016 16:15:22 with OCaml \n4.01.0\n   coqtop version 8.5 (January 2016) *)\nInductive False := .\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := case proof_admitted.\nRequire Coq.Init.Datatypes.\nImport Coq.Init.Notations.\nGlobal Set Universe Polymorphism.\nNotation ""A -> B"" := (forall (_ : A), B) : type_scope.\nModule Export Datatypes.\n  Set Implicit Arguments."
388589592,4525,2018-05-12 23:10:53,"(* File reduced by coq-bug-finder from original input, then from 953 lines to\n170 lines, then from 184 lines to 170 lines, then from 705 lines to 214 lines,\nthen from 228 lines to 214 lines *)\n(* coqc version 8.5 (January 2016) compiled on Jan 23 2016 16:15:22 with OCaml\n4.01.0\n   coqtop version 8.5 (January 2016) *)\nInductive False := .\nAxiom proof_admitted : False.\n\nLtac admit := case proof_admitted.\nRequire Coq.Init.Datatypes.\nImport Coq.Init.Notations.\nGlobal Set Universe Polymorphism.\nNotation ""A -> B"" := (forall (_ : A), B) : type_scope.\nModule Export Datatypes."
337541067,4632,2016-03-20 16:42:38,"(* File reduced by coq-bug-finder from original input, then from 1291 lines to 305 lines, then from 323 lines to 11 lines, then from 86 lines to 13 lines, then from 188 lines to 13 lines, then from 273 lines to 106 lines, then from 166 lines to 106 lines, then from 193 lines to 121 lines, then from 295 lines to 127 lines, then from 226 lines to 167 lines, then from 223 lines to 168 lines, then from 375 lines to 206 lines, then from 246 lines to 209 lines, then from 2028 lines to 210 lines, then from 224 lines to 211 lines, then from 239 lines to 201 lines, then from 215 lines to 201 lines, then from 198 lines to 8 lines, then from 22 lines to 8 lines *)\n(* coqc version 8.5 (February 2016) compiled on Feb 21 2016 15:26:16 with OCaml 4.02.3\n   coqtop version 8.5 (February 2016) *)\nRequire Coq.Setoids.Setoid.\n\nRecord refineADT {Sig} (A B : Sig) := { AbsR : Prop }.\nGoal forall (T : Type) (a1 a2 : T), @ refineADT T a2 a1.\n  intros.\n  cut (a2 = a1); [ intro x | ].\n  setoid_rewrite x. (* Error: Conversion test raised an anomaly *)\nNote that this error is present even if [x] is not a defined identifier."
337528764,3888,2014-12-27 05:53:17,"(* File reduced by coq-bug-finder from original input, then from 1426 lines to 322 lines, then from 284 lines to 223 lines, then from 238 lines to 201 lines *)\n(* coqc version trunk (December 2014) compiled on Dec 23 2014 22:6:43 with OCaml 4.01.0\n   coqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (90ed6636dea41486ddf2cc0daead83f9f0788163) *)\nRequire Coq.Program.Program.\nImport Coq.Program.Program.\nImport Coq.Lists.List.\nSet Asymmetric Patterns.\nAxiom string : Set.\n\nSet Implicit Arguments.\n\nRecord string_like (CharType : Type) :=\n  {\n    String :> Type;\n    Singleton : CharType -> String where ""[ x ]"" := (Singleton x);"
337518475,3273,2014-04-08 22:33:14,"(* File reduced by coq-bug-finder from 1099 lines to 59 lines, then from 77 lines to 41 lines. *)\n\nParameter value : Set.\nParameter pid : Set.\nParameter address: Set.\n\nAxiom action : Set.\nAxiom proc : Set.\nParameter processes : Set.\nParameter procs_lookup: processes -> pid -> option proc.\nParameter procs_disj_add: processes -> pid -> proc -> option processes.\nNotation "" P &&& [ i -> p ] "" := (procs_disj_add P i p) (no associativity, at level 10, i at level 0).\nCoercion procs_lookup : processes >-> Funclass.\n\nLemma procs_disjoint_add_lookup_neq: forall {Procs Procs'} i j p,"
337520952,3425,2014-07-15 22:19:41,"(* File reduced by coq-bug-finder from original input, then from 17950 lines to 11826 lines, then from 10956 lines to 10214 lines, then from 10225 lines to 6285 lines, then from 6300 lines to 901 lines, then from 833 lines to 552 lines, then from 529 lines to 478 lines *)\n\nSet Universe Polymorphism.\nSet Implicit Arguments.\nGeneralizable All Variables.\nAxiom admit : forall {T}, T.\nReserved Infix ""o"" (at level 40, left associativity).\nDefinition relation (A : Type) := A -> A -> Type.\nClass Symmetric {A} (R : relation A) := symmetry : forall x y, R x y -> R y x.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDelimit Scope path_scope with path.\nLocal Open Scope path_scope.\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x := match p with idpath => idpath end.\nInstance symmetric_paths {A} : Symmetric (@ paths A) | 0 := @ inverse A."
337518308,3263,2014-03-27 17:02:08,"(* File reduced by coq-bug-finder from originally 10918 lines, then 3649 lines to 3177 lines, then from 3189 lines to 3164 lines, then from 2653 lines to 2496 lines,  2653 lines, then from 1642 lines to 651 lines, then from 736 lines to 473 lines, then from 433 lines to 275 lines, then from 258 lines to 235 lines. *)\nGeneralizable All Variables.\nSet Implicit Arguments.\n\nArguments fst {_ _} _.\nArguments snd {_ _} _.\n\nAxiom cheat : forall {T}, T.\n\nReserved Notation ""g 'o' f"" (at level 40, left associativity).\n\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\nArguments idpath {A a} , [A] a.\nNotation ""x = y"" := (paths x y) : type_scope.\n"
337529302,3925,2015-01-17 03:27:27,"(* File reduced by coq-bug-finder from original input, then from 2352 lines to 167 lines, then from 52 lines to 37 lines )\n( coqc version 8.5beta1 (January 2015) compiled on Jan 16 2015 6:5:37 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (13140f2) *)\nNotation compose := (fun g f x => g (f x)).\nNotation ""g 'o' f"" := (compose g f) (at level 40, left associativity) : function_scope.\nOpen Scope function_scope.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\nArguments idpath {A a} , [A] a.\nNotation ""x = y :> A"" := (@ paths A x y) : type_scope.\nNotation ""x = y"" := (x = y :>_) : type_scope.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with idpath => idpath end.\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A }.\nNotation ""f ^-1"" := (@ equiv_inv _ _ f _) (at level 3, format ""f '^-1'"") : equiv_scope.\nLocal Open Scope equiv_scope.\nGeneralizable Variables A B C f g."
337555076,5599,2017-06-14 02:38:21,"(* File reduced by coq-bug-finder from original input, then from 425 lines to \n28 lines, then from 581 lines to 38 lines, then from 218 lines to 65 lines, \nthen from 222 lines to 86 lines, then from 202 lines to 87 lines, then from 447 \nlines to 107 lines, then from 221 lines to 142 lines, then from 335 lines to \n195 lines, then from 350 lines to 195 lines, then from 217 lines to 196 lines, \nthen from 144 lines to 60 lines, then from 76 lines to 60 lines, then from 53 \nlines to 36 lines, then from 52 lines to 37 lines *)\n(* coqc version 8.6 (June 2017) compiled on Jun 12 2017 14:31:24 with OCaml \n4.02.3\n   coqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.6,(HEAD \ndetached from 7e992fa) (ce1e1dba837ad6e2c79ff7e531b5e3adea3cd327) *)\n\nContext (base_type_code : Type).\nInductive flat_type := Tbase (T : base_type_code) | Unit | Prod (A B : \nflat_type)."
337536434,4339,2015-09-09 06:27:52,"( File reduced by coq-bug-finder from original input, then from 4286 lines to 550 lines, then from 570 lines to 34 lines )\n( coqc version 8.5beta2 (August 2015) compiled on Aug 19 2015 19:14:3 with OCaml 4.01.0\ncoqtop version cagnode12:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (15e6e2d) *)\nRequire Coq.Program.Program.\nRequire Coq.Strings.String.\nExport Coq.Program.Program.\nClass StringLike {Char : Type} :=\n{\nString :> Type;\ntake : nat -> String -> String\n}.\nArguments StringLike : clear implicits.\nSection foo.\nContext (T : Type) (P : T -> Prop).\nNotation StringT := { r : T | P r } (only parsing)."
337550857,5320,2017-01-20 05:21:00,"(* File reduced by coq-bug-finder from original input, then from 619 lines to \n61 lines, then from 210 lines to 101 lines, then from 203 lines to 103 lines, \nthen from 217 lines to 107 lines, then from 299 lines to 121 lines, then from \n170 lines to 121 lines, then from 135 lines to 121 lines *)\n(* coqc version 8.6rc1 (December 2016) compiled on Dec 8 2016 13:43:59 with \nOCaml 4.02.3\n   coqtop version 8.6rc1 (December 2016) *)\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := abstract case proof_admitted.\nRequire Coq.ZArith.ZArith.\n\nGlobal Set Asymmetric Patterns.\nImport Coq.ZArith.BinInt.\n\nClass Decidable (P : Prop) := dec : {P} + {~P}."
337550858,5320,2017-01-20 05:37:13,"(* File reduced by coq-bug-finder from original input, then from 619 lines to \n61 lines, then from 210 lines to 101 lines, then from 203 lines to 103 lines, \nthen from 217 lines to 107 lines, then from 299 lines to 121 lines, then from \n170 lines to 121 lines, then from 135 lines to 121 lines, then from 118 lines \nto 57 lines, then from 71 lines to 57 lines *)\n(* coqc version 8.6rc1 (December 2016) compiled on Dec 8 2016 13:43:59 with \nOCaml 4.02.3\n   coqtop version 8.6rc1 (December 2016) *)\nRequire Coq.ZArith.ZArith.\n\nGlobal Set Asymmetric Patterns.\nImport Coq.ZArith.BinInt.\n\nReserved Notation ""A <- X ; B"" (at level 70, right associativity, format ""'[v' \nA  <-  X ; '/' B ']'"")."
337521289,3448,2014-07-21 12:46:49,"(* File reduced by coq-bug-finder from original input, then from 16780 lines to 19369 lines, then from 18856 lines to 689 lines, then from 700 lines to 686 lines, then from 594 lines to 379 lines, then from 392 lines to 391 lines, then from 377 lines to 360 lines *)\nRequire Coq.Setoids.Setoid.\nImport Coq.Classes.Morphisms.\nImport Coq.Setoids.Setoid.\nGeneralizable All Variables.\nAxiom admit : forall {T}, T.\nDefinition BITS (n : nat) : Set.\nAdmitted.\nDefinition BYTE   := BITS 8.\nDefinition DWORD  := BITS 32.\nClass Equiv (A : Type) := equiv : relation A.\nInfix ""==="" := equiv (at level 70, no associativity).\nClass type (A : Type) {e : Equiv A} := eq_equiv : Equivalence equiv.\nInstance Equiv_PropP : Equiv Prop := iff.\nGlobal Instance ge_Pre: PreOrder ge."
337551868,5396,2017-03-13 23:26:06,"(* File reduced by coq-bug-finder from original input, then from 363 lines to \n149 lines, then from 324 lines to 175 lines, then from 305 lines to 171 lines, \nthen from 606 lines to 180 lines, then from 426 lines to 205 lines, then from \n1620 lines to 190 lines, then from 192 lines to 10 lines, then from 24 lines to \n10 lines *)\n(* coqc version trunk (March 2017) compiled on Mar 13 2017 15:45:4 with OCaml \n4.04.0\n   coqtop version cauchy:/Users/tchajed/code/sw/coq-trunk,trunk \n(9add418e7699a812e7cf5257680a7550234deb2a) *)\n\nTheorem type_eq_self@ {i j} (A:Type@ {i}) (H: A <> A :> Type@ {j}) : False.\nProof.\n  congruence.\nQed."
337551869,5396,2017-03-13 23:29:10,"(* File reduced by coq-bug-finder from original input, then from 363 lines to \n149 lines, then from 324 lines to 175 lines, then from 305 lines to 171 lines, \nthen from 606 lines to 180 lines, then from 426 lines to 205 lines, then from \n1620 lines to 190 lines, then from 192 lines to 10 lines, then from 24 lines to \n10 lines *)\n(* coqc version trunk (March 2017) compiled on Mar 13 2017 15:45:4 with OCaml \n4.04.0\n   coqtop version \n26-5-163.dynamic.csail.mit.edu:/Users/tchajed/code/sw/coq-trunk,trunk \n(9add418e7699a812e7cf5257680a7550234deb2a) *)\n\nSet Printing All.\nSet Printing Universes.\n\nTheorem type_eq_self@ {i j} (A:Type@ {i}) (H: A <> A :> Type@ {j}) : False."
886105916,14708,2021-07-24 20:11:08,"(* File reduced by coq-bug-finder from original input, then from 42 lines to 13 lines, then from 38 lines to 2148 lines, then from 2152 lines to 55 lines, then from 78 lines to 937 lines, then from 940 lines to 32 lines, then from 36 lines to 32 lines *)\n(* coqc version 8.13.2 (April 2021) compiled on Apr 3 2021 23:10:57 with OCaml 4.05.0\n   coqtop version 8.13.2 (April 2021) *)\nRequire Coq.Strings.String.\nImport Coq.Strings.String.\n\nInductive ty : Type :=\n  | Ty_Bool  : ty\n  | Ty_Arrow : ty -> ty -> ty.\n\nInductive tm : Type :=\n  | tm_var   : string -> tm\n  | tm_app   : tm -> tm -> tm\n  | tm_abs   : string -> ty -> tm -> tm\n  | tm_true  : tm"
886109974,14708,2021-07-24 20:51:53,"(* File reduced by coq-bug-finder from original input, then from 42 lines to 13 lines, then from 38 lines to 2148 lines, then from 2152 lines to 14 lines, then from 37 lines to 896 lines, then from 899 lines to 13 lines, then from 17 lines to 12 lines *)\n(* coqc version 8.13.2 (April 2021) compiled on Apr 3 2021 23:10:57 with OCaml 4.05.0\n   coqtop version 8.13.2 (April 2021) *)\nDeclare Custom Entry stlc.\nNotation ""<{ e }>"" := e (e custom stlc at level 99).\nNotation ""x"" := x (in custom stlc at level 0, x constr at level 0).\n\nCompute (\n  match 123 with\n  | <{ unit }> when true => _\n  | _ => 1\n  end\n).\n\nIntermediate Coq File (useful for debugging if minimization did not go as far as you wanted)"
337534679,4231,2015-05-09 18:19:04,"(* File reduced by coq-bug-finder from original input, then from 981 lines to 33 lines *)\n(* coqc version 8.5beta2 (May 2015) compiled on May 5 2015 15:20:21 with OCaml 4.01.0\n   coqtop version 8.5beta2 (May 2015) *)\n\nAxiom ap : forall {A B:Type} (f:A -> B) {x y:A} (p:x = y), f x = f y.\n\nDefinition Sect {A B : Type} (s : A -> B) (r : B -> A) :=\n  forall x : A, r (s x) = x.\n\nClass IsEquiv {A B : Type} (f : A -> B) := BuildIsEquiv {\n  equiv_inv : B -> A ;\n  eisretr : Sect equiv_inv f;\n  eissect : Sect f equiv_inv;\n  eisadj : forall x : A, eisretr (f x) = ap f (eissect x)\n}."
337551186,5350,2017-02-09 21:10:16,"(* File reduced by coq-bug-finder from original input, then from 2710 lines to \n84 lines, then from 308 lines to 89 lines, then from 103 lines to 99 lines *)\n(* coqc version trunk (February 2017) compiled on Feb 9 2017 9:47:18 with OCaml \n4.04.0\n   coqtop version cauchy.local:/Users/tchajed/code/sw/coq,ltac-missing-args-msg \n(2c7df345aead8d44a835e609caa41e348bfb021c) *)\nModule Export AdmitTactic.\nModule Import LocalFalse.\nInductive False := .\nEnd LocalFalse.\n\nSet Universe Polymorphism.\nSet Implicit Arguments.\n\nDefinition EqDec (T : Type) := forall (a b : T), {a = b} + {a <> b}."
337519733,3345,2014-05-25 09:05:06,"(* File reduced by coq-bug-finder from original input, then from 1972 lines to 136 lines, then from 119 lines to 105 lines *)\nGlobal Set Implicit Arguments.\nRequire Import Coq.Lists.List Program.\nSection IndexBound.\n  Context {A : Set}.\n  Class IndexBound (a : A) (Bound : list A) :=\n    { ibound :> nat;\n      boundi : nth_error Bound ibound = Some a}.\n  Global Arguments ibound [a Bound] _ .\n  Global Arguments boundi [a Bound] _.\n  Record BoundedIndex (Bound : list A) := { bindex :> A; indexb :> IndexBound bindex Bound }.\nEnd IndexBound.\nContext {A : Type} {C : Set}.\nVariable (projAC : A -> C).\nLemma None_neq_Some"
337523785,3594,2014-09-08 16:21:23,"(* File reduced by coq-bug-finder from original input, then from 8752 lines to 735 lines, then from 735 lines to 310 lines, then from 228 lines to 105 lines, then from 98 lines to 41 lines *)\n(* coqc version trunk (September 2014) compiled on Sep 6 2014 6:15:6 with OCaml 4.01.0\n   coqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (3ea6d6888105edd5139ae0a4d8f8ecdb586aff6c) *)\nNotation idmap := (fun x => x).\nAxiom path_forall : forall {A : Type} {P : A -> Type} (f g : forall x : A, P x), (forall x, f x = g x) -> f = g.\nLocal Set Primitive Projections.\nRecord PreCategory := { object :> Type ; morphism : object -> object -> Type }.\nBind Scope category_scope with PreCategory.\nSet Implicit Arguments.\nDelimit Scope functor_scope with functor.\nRecord Functor (C D : PreCategory) := {}.\nDefinition opposite (C : PreCategory) : PreCategory := @ Build_PreCategory C (fun s d => morphism C d s).\nNotation ""C ^op"" := (opposite C) (at level 3, format ""C '^op'"") : category_scope.\nDefinition oppositeF C D (F : Functor C D) : Functor C^op D^op := Build_Functor (C^op) (D^op).\nLocal Notation ""F ^op"" := (oppositeF F) (at level 3, format ""F ^op"") : functor_scope."
337541042,4631,2016-03-20 16:33:49,"(* File reduced by coq-bug-finder from original input, then from 1373 lines to 16 lines *)\n(* coqc version 8.5 (March 2016) compiled on Mar 20 2016 12:6:5 with OCaml 4.02.3\n   coqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.5,v8.5 (09c2011fbdbb2ac1ce33e5abe52d93b907b21a3c) *)\nRequire Coq.Sets.Ensembles.\n\nGoal forall (T : Type) (computes_to'' : Ensembles.Ensemble T -> T -> Prop) (U : Set) (v : T * U)\n            (bind : Ensembles.Ensemble T -> (T -> Ensembles.Ensemble (T * U)) -> Ensembles.Ensemble (T * U))\n            (computes_to' : Ensembles.Ensemble (T * U) -> T * U -> Prop),\n    (forall (ca : Ensembles.Ensemble T) (f : T -> Ensembles.Ensemble (T * U)) (a : T) (b : T * U),\n        computes_to'' ca a -> computes_to' (f a) b -> computes_to' (bind ca f) b) ->\n    exists k : T * U, computes_to' (bind (fun r_n : T => fst k = r_n) (fun r_n' : T => Ensembles.Singleton (T * U) (r_n', snd k))) v.\n  intros ?????? bind_computes.\n  eexists.\n  Timeout 1 match goal with\n            | [ |- computes_to' (bind _ _) _ ]"
337541043,4631,2016-03-20 16:58:32,"(* File reduced by coq-bug-finder from original input, then from 1373 lines to 16 lines *)\n(* coqc version 8.5 (March 2016) compiled on Mar 20 2016 12:6:5 with OCaml 4.02.3\n   coqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.5,v8.5 (09c2011fbdbb2ac1ce33e5abe52d93b907b21a3c) *)\nRequire Import Coq.Init.Notations.\nNotation ""A -> B"" := (forall (_ : A), B) : type_scope.\n\nInductive ex {A:Type} (P:A -> Prop) : Prop :=\n  ex_intro : forall x:A, P x -> ex (A:=A) P.\n\nGoal forall (T : Type) (computes_to'' : (T -> Prop) -> T -> Prop) (v : T) (bind : (T -> Prop) -> (T -> T -> Prop) -> T -> Prop)\n            (computes_to' : (T -> Prop) -> T -> Prop) (R : T -> T -> Prop),\n    (forall (ca : T -> Prop) (f : T -> T -> Prop) (a b : T), computes_to'' ca a -> computes_to' (f a) b -> computes_to' (bind ca f) b) ->\n    ex (fun k : T => computes_to' (bind (fun r_n : T => R k r_n) (fun r_n' _ : T => R k r_n')) v).\n  intros ?????? bind_computes.\n  eexists."
337532180,4095,2015-02-25 23:54:44,"(* File reduced by coq-bug-finder from original input, then from 5752 lines to 3828 lines, then from 2707 lines to 558 lines, then from 472 lines to 168 lines, then from 110 lines to 101 lines, then from 96 lines to 77 lines, then from 80 lines to 64 lines, then from 92 lines to 79 lines *)\n(* coqc version 8.5beta1 (February 2015) compiled on Feb 23 2015 18:32:3 with OCaml 4.01.0\n   coqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (ebfc19d792492417b129063fb511aa423e9d9e08) *)\nRequire Import Coq.Setoids.Setoid.\nGeneralizable All Variables.\nAxiom admit : forall {T}, T.\nClass Equiv (A : Type) := equiv : relation A.\nClass type (A : Type) {e : Equiv A} := eq_equiv : Equivalence equiv.\nClass ILogicOps Frm := { lentails: relation Frm;\n                         ltrue: Frm;\n                         land: Frm -> Frm -> Frm;\n                         lor: Frm -> Frm -> Frm }.\nInfix ""|--""  := lentails (at level 79, no associativity).\nClass ILogic Frm {ILOps: ILogicOps Frm} := { lentailsPre:> PreOrder lentails }.\nDefinition lequiv `{ILogic Frm} P Q := P |-- Q /\ Q |-- P."
337520549,3395,2014-06-23 00:23:42,"(* File reduced by coq-bug-finder from originally 10918 lines, then 3649 lines to 3177 lines, then from 3189 lines to 3164 lines, then from 2653 lines to 2496 lines,  2653 lines, then from 1642 lines to 651 lines, then from 736 lines to 473 lines, then from 433 lines to 275 lines, then from 258 lines to 235 lines. *)\nGeneralizable All Variables.\nSet Implicit Arguments.\n\nArguments fst {_ _} _.\nArguments snd {_ _} _.\n\nAxiom cheat : forall {T}, T.\n\nReserved Notation ""g 'o' f"" (at level 40, left associativity).\n\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\nArguments idpath {A a} , [A] a.\nNotation ""x = y"" := (paths x y) : type_scope.\n"
337520554,3395,2014-07-20 14:42:04,"(* File reduced by coq-bug-finder from original input, then from 8772 lines to 758 lines, then from 727 lines to 589 lines, then from 593 lines to 579 lines *)\nAxiom ADMIT : False. Ltac admit := destruct ADMIT.\nSet Universe Polymorphism.\nDefinition relation (A : Type) := A -> A -> Type.\n\nClass Reflexive {A} (R : relation A) :=\n  reflexivity : forall x : A, R x x.\n\nClass Symmetric {A} (R : relation A) :=\n  symmetry : forall x y, R x y -> R y x.\n\nClass Transitive {A} (R : relation A) :=\n  transitivity : forall x y z, R x y -> R y z -> R x z.\n\nTactic Notation ""etransitivity"" open_constr(y) :="
517466498,7160,2019-08-01 21:34:10,"(* File reduced by coq-bug-finder from original input, then from 625 lines to 417 lines, then from 91 lines to 44 lines, then from 203 lines to 47 lines, then from 90 lines to 46 lines, then from 71 lines to 50 lines, then from 65 lines to 50 lines *)\n(* coqc version 8.10+alpha (July 2019) compiled on Jul 16 2019 14:45:28 with OCaml 4.07.1\n   coqtop version 30-10-74.wireless.csail.mit.edu:/Users/tchajed/code/sw/coq-master/_build/default,master (ba1bb7581a5ad0969d35911fffdf61f150e0536f) *)\nRequire Coq.ZArith.ZArith.\n\nSet Implicit Arguments.\n\nInductive Return (B T: Type) : Type :=\n| Val (b: B) (t: T)\n| Err.\n\nDefinition relation A T := A -> Return A T -> Prop.\n\nDefinition rimpl {A} {T} (r1 r2: relation A T) :=\n  forall x y, r1 x y -> r2 x (Err _ _) \/ r2 x y."
337527394,3811,2014-11-14 11:08:35,"(* File reduced by coq-bug-finder from original input, then from 9557 lines to 33 lines *)\n(* coqc version trunk (November 2014) compiled on Nov 11 2014 15:8:39 with OCaml 3.12.1\n   coqtop version trunk (November 2014) *)\n\nDefinition Type1 := Eval hnf in let gt := (Set : Type@ {i}) in Type@ {i}.\n\nDefinition Type2 := Eval hnf in let gt := (Type1 : Type@ {i}) in Type@ {i}.\n\nDefinition Type2le := Eval hnf in let gt := (Set : Type@ {i}) in\n                                  let ge := ((fun x => x) : Type1 -> Type@ {i}) in Type@ {i}.\n\nParameter ReflectiveSubuniverse : Type2@ {u a}.\n\nParameter inO_internal : forall (O : ReflectiveSubuniverse@ {u a}),\n                           Type2le@ {i a} -> Type2le@ {i a}."
337519726,3344,2014-05-25 07:39:00,"(* File reduced by coq-bug-finder from original input, then from 716 lines to 197 lines, then from 206 lines to 162 lines, then from \\n163 lines to 73 lines *)\nRequire Import Coq.Sets.Ensembles.\nRequire Import Coq.Strings.String.\nGlobal Set Implicit Arguments.\nGlobal Set Asymmetric Patterns.\nLtac clearbodies := repeat match goal with | [ H := _ |- _ ] => clearbody H end.\n\nInductive Comp : Type -> Type :=\n| Return : forall A, A -> Comp A\n| Bind : forall A B, Comp A -> (A -> Comp B) -> Comp B.\nInductive computes_to : forall A, Comp A -> A -> Prop :=\n| ReturnComputes : forall A v, @ computes_to A (Return v) v\n| BindComputes : forall A B comp_a f comp_a_value comp_b_value,\n                   @ computes_to A comp_a comp_a_value"
337536460,4340,2015-09-09 06:29:18,"( File reduced by coq-bug-finder from original input, then from 4286 lines to 550 lines, then from 570 lines to 34 lines )\n( coqc version 8.5beta2 (August 2015) compiled on Aug 19 2015 19:14:3 with OCaml 4.01.0\ncoqtop version cagnode12:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (15e6e2d) *)\nRequire Coq.Program.Program.\nRequire Coq.Strings.String.\nExport Coq.Program.Program.\nClass StringLike {Char : Type} :=\n{\nString :> Type;\ntake : nat -> String -> String\n}.\nArguments StringLike : clear implicits.\nAxiom proof_admitted : False.\nSection foo.\nContext (T : Type) (P : T -> Prop)."
337534836,4242,2015-05-23 00:27:49,"(* File reduced by coq-bug-finder from original input, then from 491 lines to 54 lines *)\n(* coqc version 8.5beta2 (May 2015) compiled on May 12 2015 11:34:42 with OCaml 4.01.0\n   coqtop version cagnode13:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (f480f07c232b4bcc4ea67bf0577e267d0fdc35f4) *)\n\nGlobal Set Universe Polymorphism.\nSet Implicit Arguments.\nInductive identity (A : Type) (a : A) : A -> Type\n  := identity_refl : identity a a.\nInductive list (A : Type) : Type := nil | cons (x : A) (ls : list A).\nClass TMonad (T: Type -> Type) :=\n  { join  {A: Type} (t: T (T A)): T A;\n    fmap {A B: Type}: (A -> B) -> (T A -> T B) }.\nSection Algebras.\n  Context {T: Type -> Type} `{TMonad T}.\n  Variable act: T Type -> Type."
382616904,7273,2018-04-19 05:42:51,"(* File reduced by coq-bug-finder from original input, then from 4431 lines to 3382 lines, then from 3059 lines to 2535 lines, then from 2589 lines to 2515 lines, then from 2606 lines to 2524 lines, then from 2682 lines to 2570 lines, then from 2715 lines to 2585 lines, then from 2720 lines to 2585 lines, then from 2644 lines to 2585 lines, then from 2675 lines to 2585 lines, then from 2687 lines to 2585 lines, then from 3027 lines to 2585 lines, then from 2715 lines to 2585 lines, then from 2685 lines to 2585 lines, then from 2763 lines to 2585 lines, then from 2647 lines to 2585 lines, then from 2692 lines to 2595 lines, then from 2781 lines to 2612 lines, then from 2700 lines to 2688 lines, then from 4973 lines to 2642 lines, then from 2758 lines to 2642 lines, then from 2728 lines to 2642 lines, then from 2806 lines to 2642 lines, then from 2690 lines to 2642 lines, then from 2717 lines to 2642 lines, then from 2701 lines to 2642 lines, then from 2667 lines to 2642 lines, then from 3356 lines to 464 lines, then from 375 lines to 362 lines, then from 378 lines to 362 lines *)\n(* coqc version 8.7.1 (December 2017) compiled on Dec 22 2017 15:56:58 with OCaml 4.02.3\n   coqtop version 8.7.1 (December 2017) *)\nRequire Coq.FSets.FMapPositive.\n\nGlobal Set Asymmetric Patterns.\nReserved Notation ""A <- X ; B"" (at level 70, X at next level, right associativity, format ""'[v' A  <-  X ; '/' B ']'"").\nDefinition bind {A B} (v : option A) (f : A -> option B) : option B\n  := match v with\n     | Some v => f v\n     | None => None\n     end.\nDelimit Scope option_scope with option.\nNotation ""A <- X ; B"" := (bind X (fun A => B%option)) : option_scope.\nReserved Infix ""@"" (left associativity, at level 11)."
337522678,3529,2014-08-19 18:13:32,"(* File reduced by coq-bug-finder from original input, then from 5752 lines to 3828 lines, then from 2707 lines to 558 lines, then from 472 lines to 168 lines, then from 110 lines to 101 lines, then from 96 lines to 13 lines *)\nRequire Coq.Setoids.Setoid.\nImport Coq.Setoids.Setoid.\nClass ILogicOps Frm := { lentails: relation Frm }.\nInstance ILogicOps_Prop : ILogicOps Prop | 2 := {| lentails P Q := P -> Q |}.\n(* Toplevel input, characters 82-88:\nError:\nIn environment\nP : Type\nQ : Type\nThe term ""P -> Q"" has type ""Type"" while it is expected to have type ""Prop"". *)"
337526311,3749,2014-10-18 07:17:21,"(* File reduced by coq-bug-finder from original input, then from 457 lines to 45 lines *)\n(* coqc version trunk (October 2014) compiled on Oct 16 2014 13:27:5 with OCaml 4.01.0\n   coqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (d0da8a75cd1d600afa68da5e995d39a415234c2d) *)\nClass Foo T := { a : T ; b : bool }.\nSection foo.\n  Context (b: bool).\n  Instance foo : Foo Set := {| a := nat ; b := b |}. (* Error: This record contains fields of different records. *)\nEnd foo.\nSection bar.\n  Context (a: Set).\n  Instance bar : Foo Set := {| a := a ; b := true |}. (* Error: a: Not a projection *)\nEnd bar.\nIf Instance is replaced with Definition, both 8.4 and trunk give these error messages.  It's unclear to me which is the desired behavior (though the ""This record contains fields of different records"" message is definitely wrong), but I'm leaning towards ""no error message, for both Instance and Definition, but, in any case, if trunk behaves differently from 8.4, this should be documented in CHANGES."
337526053,3732,2014-10-14 04:24:21,"(* File reduced by coq-bug-finder from original input, then from 2073 lines to 358 lines, then from 359 lines to 218 lines, then from 107 lines to 92 lines *)\n(* coqc version trunk (October 2014) compiled on Oct 11 2014 1:13:41 with OCaml 4.01.0\n   coqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (d65496f09c4b68fa318783e53f9cd6d5c18e1eb7) *)\nRequire Coq.Lists.List.\n\nImport Coq.Lists.List.\n\nSet Implicit Arguments.\nGlobal Set Asymmetric Patterns.\n\nSection machine.\n  Variables pc state : Type.\n\n  Inductive propX (i := pc) (j := state) : list Type -> Type :=\n  | Inj : forall G, Prop -> propX G"
337529117,3910,2015-01-11 09:32:16,"(* File reduced by coq-bug-finder from original input, then from 2352 lines to 162 lines, then from 138 lines to 50 lines *)\n(* coqc version trunk (January 2015) compiled on Jan 10 2015 10:54:47 with OCaml 4.01.0\n   coqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (b858f939f33dc4bc4c8e470ed62310ef15c59a99) *)\n\nNotation compose g f := (fun x => g (f x)).\nNotation ""g 'o' f"" := (compose g f) (at level 40, left associativity) : function_scope.\nOpen Scope function_scope.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\nArguments idpath {A a} , [A] a.\nNotation ""x = y :> A"" := (@ paths A x y) : type_scope.\nNotation ""x = y"" := (x = y :>_) : type_scope.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with idpath => idpath end.\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A }.\nNotation ""f ^-1"" := (@ equiv_inv _ _ f _) (at level 3, format ""f '^-1'"") : equiv_scope.\nLocal Open Scope equiv_scope."
337524098,3610,2014-09-11 19:44:23,"(* File reduced by coq-bug-finder from original input, then from 7251 lines to 6610 lines, then from 476 lines to 47 lines, then from 36 lines to 20 lines *)\n(* coqc version trunk (September 2014) compiled on Sep 11 2014 14:48:8 with OCaml 4.01.0\n   coqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (580b25e05c7cc9e7a31430b3d9edb14ae12b7598) *)\nSet Implicit Arguments.\nAxiom admit : forall {T}, T.\nRecord PreCategory := { object : Type ; morphism : object -> object -> Type ; identity : forall x, morphism x x }.\nLocal Set Primitive Projections.\nRecord Functor (C D : PreCategory) :=\n  { object_of : object C -> object D;\n    morphism_of : forall s d, morphism C s d -> morphism D (object_of s) (object_of d);\n    identity_of : forall x, morphism_of _ _ (identity _ x) = identity _ _ }.\nDefinition functor_category C D : PreCategory\n  := @ Build_PreCategory (Functor C D) admit admit.\nGoal forall (H0 H2 C : PreCategory) (H3 : Functor H0 (functor_category C H2))\n            (H6 : object H0) (x : object C),"
337520935,3424,2014-07-15 21:14:57,"(* File reduced by coq-bug-finder from original input, then from 6056 lines to 215 lines, then from 229 lines to 220 lines, then from\\n 226 lines to 40 lines *)\nSet Universe Polymorphism.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nClass Contr_internal (A : Type) := BuildContr { center : A ; contr : (forall y : A, center = y) }.\nInductive trunc_index : Type := minus_two | trunc_S (x : trunc_index).\nBind Scope trunc_scope with trunc_index.\nFixpoint IsTrunc_internal (n : trunc_index) (A : Type) : Type :=\n  match n with\n    | minus_two => Contr_internal A\n    | trunc_S n' => forall (x y : A), IsTrunc_internal n' (x = y)\n  end.\nNotation minus_one:=(trunc_S minus_two).\nNotation ""0"" := (trunc_S minus_one) : trunc_scope.\nClass IsTrunc (n : trunc_index) (A : Type) : Type := Trunc_is_trunc : IsTrunc_internal n A."
337525403,3699,2014-10-07 14:35:57,"(* File reduced by coq-bug-finder from original input, then from 9593 lines to 104 lines, then from 187 lines to 103 lines, then from 113 lines to 90 lines *)\n(* coqc version trunk (October 2014) compiled on Oct 1 2014 18:13:54 with OCaml 4.01.0\n   coqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (68846802a7be637ec805a5e374655a426b5723a5) *)\nAxiom transport : forall {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x), P y.\nInductive trunc_index := minus_two | trunc_S (_ : trunc_index).\nAxiom IsTrunc : trunc_index -> Type -> Type.\nExisting Class IsTrunc.\nAxiom Contr : Type -> Type.\nInductive Trunc (n : trunc_index) (A :Type) : Type := tr : A -> Trunc n A.\nModule NonPrim.\n  Unset Primitive Projections.\n  Set Implicit Arguments.\n  Record sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\n  Notation ""{ x : A  & P }"" := (sigT (fun x:A => P)) : type_scope.\n  Unset Implicit Arguments."
337547641,5107,2016-09-29 00:23:46,"(* File reduced by coq-bug-finder from original input, then from 165 lines to \n24 lines, then from 121 lines to 28 lines, then from 146 lines to 29 lines, \nthen from 326 lines to 30 lines, then from 44 lines to 30 lines *)\n(* coqc version 8.6.0 (September 2016) compiled on Sep 27 2016 19:1:59 with \nOCaml 4.02.3\n   coqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.6,v8.6 \n(72c1fefcfb3f0dff02005034685f6b58ff84b3cc) *)\n\nFixpoint tuple' T n : Type :=\n  match n with\n  | O => T\n  | S n' => (tuple' T n' * T)%type\n  end.\n\nReserved Notation ""'dlet' x := y 'in' f"""
337544024,4839,2016-06-19 21:47:54,"( File reduced by coq-bug-finder from original input, then from 21 lines to 7 lines )\n( coqc version 8.4pl6 (June 2016) compiled on Jun 13 2016 21:12:50 with OCaml 4.02.3\ncoqtop version 8.4pl6 (June 2016) *)\nRequire Import Coq.FSets.FMapInterface.\nTime Module FMapExtensions_fun (E: DecidableType) (Import M: WSfun E). (* Anomaly: Uncaught exception Not_found. Please report. *)\nThis bug makes it hard to debug when things got slower between 8.4 and 8.5/trunk, so I'd appreciate a fix on the v8.4 branch."
337522440,3513,2014-08-12 21:50:43,"(* File reduced by coq-bug-finder from original input, then from 5752 lines to 3828 lines, then from 2707 lines to 558 lines, then from 472 lines to 168 lines, then from 110 lines to 101 lines, then from 96 lines to 77 lines, then from 80 lines to 64 lines *)\nRequire Coq.Setoids.Setoid.\nImport Coq.Setoids.Setoid.\nGeneralizable All Variables.\nAxiom admit : forall {T}, T.\nClass Equiv (A : Type) := equiv : relation A.\nClass type (A : Type) {e : Equiv A} := eq_equiv : Equivalence equiv.\nClass ILogicOps Frm := { lentails: relation Frm;\n                         ltrue: Frm;\n                         land: Frm -> Frm -> Frm;\n                         lor: Frm -> Frm -> Frm }.\nInfix ""|--""  := lentails (at level 79, no associativity).\nClass ILogic Frm {ILOps: ILogicOps Frm} := { lentailsPre:> PreOrder lentails }.\nDefinition lequiv `{ILogic Frm} P Q := P |-- Q /\ Q |-- P.\nInfix ""-|-""  := lequiv (at level 85, no associativity)."
337522444,3513,2015-02-25 23:45:53,"(* File reduced by coq-bug-finder from original input, then from 5752 lines to 3828 lines, then from 2707 lines to 558 lines, then from 472 lines to 168 lines, then from 110 lines to 101 lines, then from 96 lines to 77 lines, then from 80 lines to 64 lines *)\nRequire Coq.Setoids.Setoid.\nImport Coq.Setoids.Setoid.\nGeneralizable All Variables.\nAxiom admit : forall {T}, T.\nClass Equiv (A : Type) := equiv : relation A.\nClass type (A : Type) {e : Equiv A} := eq_equiv : Equivalence equiv.\nClass ILogicOps Frm := { lentails: relation Frm;\n                         ltrue: Frm;\n                         land: Frm -> Frm -> Frm;\n                         lor: Frm -> Frm -> Frm }.\nInfix ""|--""  := lentails (at level 79, no associativity).\nClass ILogic Frm {ILOps: ILogicOps Frm} := { lentailsPre:> PreOrder lentails }.\nDefinition lequiv `{ILogic Frm} P Q := P |-- Q /\ Q |-- P.\nInfix ""-|-""  := lequiv (at level 85, no associativity)."
337529312,3926,2015-01-17 05:20:39,"(* File reduced by coq-bug-finder from original input, then from 2352 lines to 162 lines, then from 48 lines to 33 lines *)\n(* coqc version 8.5beta1 (January 2015) compiled on Jan 16 2015 7:25:14 with OCaml 4.01.0\n   coqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (81489f299ef60c21ac3da1d2157b02c3b41886d1) *)\n\nNotation compose := (fun g f x => g (f x)).\nNotation ""g 'o' f"" := (compose g f) (at level 40, left associativity) : function_scope.\nOpen Scope function_scope.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with idpath => idpath end.\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A }.\nNotation ""f ^-1"" := (@ equiv_inv _ _ f _) (at level 3, format ""f '^-1'"") : equiv_scope.\nLocal Open Scope equiv_scope.\nAxiom eisretr : forall {A B} (f : A -> B) `{IsEquiv A B f} x, f (f^-1 x) = x.\nGeneralizable Variables A B C f g."
337541608,4672,2016-04-15 19:16:43,"( File reduced by coq-bug-finder from original input, then from 2227 lines to 80 lines, then from 201 lines to 85 lines, then from 680 lines to 156 lines, then from 407 lines to 203 lines, then from 356 lines to 247 lines, then from 370 lines to 273 lines, then from 450 lines to 331 lines, then from 506 lines to 333 lines, then from 536 lines to 332 lines, then from 843 lines to 338 lines, then from 639 lines to 376 lines, then from 1087 lines to 390 lines, then from 2227 lines to 392 lines, then from 453 lines to 393 lines, then from 416 lines to 393 lines, then from 511 lines to 418 lines, then from 571 lines to 450 lines, then from 630 lines to 513 lines, then from 527 lines to 514 lines, then from 449 lines to 199 lines, then from 213 lines to 199 lines, then from 190 lines to 120 lines, then from 134 lines to 120 lines )\n( coqc version 8.5 (February 2016) compiled on Feb 21 2016 15:26:16 with OCaml 4.02.3\ncoqtop version 8.5 (February 2016) *)\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := case proof_admitted.\nRequire Coq.Lists.SetoidList.\nRequire Coq.Strings.String.\nImport Coq.Strings.String.\nSection item.\nContext {Char : Type}.\nInductive item :=\n| Terminal (_ : Char -> bool)\n| NonTerminal (_ : string).\nEnd item.\nArguments item _ : clear implicits."
337541610,4672,2016-04-16 22:44:26,"( File reduced by coq-bug-finder from original input, then from 2227 lines to 80 lines, then from 201 lines to 85 lines, then from 680 lines to 156 lines, then from 407 lines to 203 lines, then from 356 lines to 247 lines, then from 370 lines to 273 lines, then from 450 lines to 331 lines, then from 506 lines to 333 lines, then from 536 lines to 332 lines, then from 843 lines to 338 lines, then from 639 lines to 376 lines, then from 1087 lines to 390 lines, then from 2227 lines to 392 lines, then from 453 lines to 393 lines, then from 416 lines to 393 lines, then from 511 lines to 418 lines, then from 571 lines to 450 lines, then from 630 lines to 513 lines, then from 527 lines to 514 lines, then from 449 lines to 199 lines, then from 213 lines to 199 lines, then from 190 lines to 120 lines, then from 134 lines to 120 lines, then from 70 lines to 50 lines, then from 64 lines to 50 lines, then from 52 lines to 30 lines, then from 44 lines to 31 lines )\n( coqc version 8.5 (February 2016) compiled on Feb 21 2016 15:26:16 with OCaml 4.02.3\ncoqtop version 8.5 (February 2016) *)\nRequire Import Coq.Strings.String.\nRequire Import Coq.Setoids.Setoid.\nRequire Import Coq.Classes.Morphisms.\nHint Extern 0 => solve [apply RelationClasses.reflexivity] : typeclass_instances.\nAxiom list_caset : forall {A} (P : list A -> Type) (N : P nil) (C : forall x xs, P (cons x xs)) ls, P ls.\nGlobal Instance list_caset_Proper {A P}\n: Proper (eq\n==> pointwise_relation _ (pointwise_relation _ eq)\n==> pointwise_relation _ eq)\n(@ list_caset A (fun _ => P)).\nAdmitted.\nInductive item : Type := ."
337522523,3518,2014-08-14 10:42:11,"jgross@ cagnode17:/coq-bug-finder$ cat baz.v\nModule Export foo.\njgross@ cagnode17:/coq-bug-finder$ coqc baz\nAnomaly: File ""kernel/safe_typing.ml"", line 252, characters 31-37: Assertion failed.\nPlease report."
337533472,4153,2015-03-23 02:58:20,"(* File reduced by coq-bug-finder from original input, then from 6735 lines to 486 lines, then from 407 lines to 72 lines )\n( coqc version 8.5beta1 (March 2015) compiled on Mar 15 2015 16:24:54 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (1b3759e) *)\nRequire Import Coq.Lists.List.\nRequire Import Coq.Sets.Ensembles.\nGlobal Set Implicit Arguments.\nClass DecideableEnsemble {A} (P : Ensemble A) :=\n{ dec : A -> bool;\ndec_decides_P : forall a, dec a = true <-> P a}.\nClass IndexBound {A : Set} (a : A) (Bound : list A) :=\n{ ibound :> nat;\nboundi : nth_error Bound ibound = Some a}.\nGlobal Instance IndexBound_tail\n{A : Set}\n(a a' : A) (Bound : list A)"
337544033,4840,2016-06-19 21:47:55,"( File reduced by coq-bug-finder from original input, then from 21 lines to 7 lines )\n( coqc version 8.4pl6 (June 2016) compiled on Jun 13 2016 21:12:50 with OCaml 4.02.3\ncoqtop version 8.4pl6 (June 2016) *)\nRequire Import Coq.FSets.FMapInterface.\nTime Module FMapExtensions_fun (E: DecidableType) (Import M: WSfun E). (* Anomaly: Uncaught exception Not_found. Please report. *)\nThis bug makes it hard to debug when things got slower between 8.4 and 8.5/trunk, so I'd appreciate a fix on the v8.4 branch."
337516963,3188,2013-12-15 20:45:49,"(* File reduced by coq-bug-finder from 1656 lines to 221 lines to 26 lines to 7 lines. *)\nRequire Import Coq.Classes.RelationClasses.\nHint Extern 0 => apply reflexivity : typeclass_instances.\nHint Extern 1 => symmetry.\nLemma foo : exists m' : Type, True.\nintuition."
337529015,3903,2015-01-06 20:08:03,"If you want to make this self-contained, you can use my coq-bug-finder (https://github.com/JasonGross/coq-bug-finder), which you can execute with\ncd HoTT/theories\npython /path/to/coq-bug-finder/find-bug.py /path/to/MWE.v bug_mwe_output_01.v -R . HoTT --coqc ../hoqc --coqtop ../hoqtop"
337533498,4155,2015-03-24 20:24:21,"(* File reduced by coq-bug-finder from original input, then from 740 lines to 323 lines, then from 330 lines to 139 lines, then from 148 lines to 84 lines, then from 244 lines to 233 lines )\n( coqc version 8.5beta1 (March 2015) compiled on Mar 17 2015 12:34:25 with OCaml 4.01.0\ncoqtop version cagnode13:/afs/csail.mit.edu/u/j/jgross/coq-8.5-require-on-the-fly,require-on-the-fly (b0bbfbc) *)\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := case proof_admitted.\nRequire Coq.Sorting.Permutation.\nRequire Coq.Strings.String.\nGlobal Set Implicit Arguments.\nLemma filter_map :\nforall {A B} f g seq,\nList.filter f (@ List.map A B g seq) =\nList.map g (List.filter (fun x => f (g x)) seq).\nadmit.\nDefined.\nSection IndexedEnsembles."
337525370,3696,2014-12-07 20:28:35,Could you provide us with a smaller test-case please? This is a bit difficult to test right now (it depends on Ssreflect). You may use Jason's coq-bug-finder to help you.
337519960,3360,2014-06-04 18:23:01,"I like coqc -time and coqtop -time, and use them in some scripts of mine (timing scripts, as well as coq-bug-finder).  Would it be possible to backport them from trunk to 8.4?"
337519713,3343,2014-05-23 21:49:11,"(* File reduced by coq-bug-finder from original input, then from 13699 lines to 656 lines, then from 584 lines to 200 lines *)\nRequire Export Coq.Lists.List.\nExport List.ListNotations.\nRecord CFGV := { Terminal : Type; VarSym : Type }.\nSection Gram.\nContext  {G : CFGV}.\nInductive  Pattern : (Terminal G) -> Type :=\n| ptleaf : forall (T : Terminal G),\nnat -> Pattern T\nwith Mixture : list (Terminal G) -> Type :=\n| mtcons : forall {h: Terminal G}\n{tl: list (Terminal G)},\nPattern h -> Mixture tl -> Mixture (h::tl).\nVariable vc : VarSym G.\nFixpoint pBVars {gs}  (p : Pattern gs) : (list nat) :="
337519830,3352,2014-05-29 16:29:15,"(* File reduced by coq-bug-finder from original input, then from 7725 lines to 78 lines, then from 51 lines to 13 lines )\nSet Universe Polymorphism.\nInductive Empty : Set := .\nRecord IsHProp (A : Type) := { foo : True }.\nDefinition hprop_Empty : IsHProp Empty := {| foo := I |}.\nGoal let U := Type in let gt := Set : U in IsHProp (Empty : U).\nsimpl.\nSet Printing Universes.\nexact hprop_Empty. ( Toplevel input, characters 21-32:\nError:\nThe term ""hprop_Empty"" has type ""IsHProp (* Set ) Empty""\nwhile it is expected to have type ""IsHProp ( Top.17 *) Empty""\n(Universe inconsistency: Cannot enforce Top.17 = Set because Set < Top.17)). *)\nDefined.\nI'm not sure what the general rule should be; intuitively, I want [IsHProp (* Set ) Foo] to mean [IsHProp ( U >= Set *) Foo].  (I think this worked in HoTT/coq, too.)  Morally, [IsHProp] has no universe level associated with it distinct from that of its argument, you should never get a universe inconsistency from unifying [IsHProp A] with [IsHProp A].  (The issue is tricker when IsHProp uses [A] elsewhere, as in:"
337553814,5522,2017-05-13 18:05:54,"( File reduced by coq-bug-finder from original input, then from 102 lines to 8\nlines, then from 193 lines to 32 lines, then from 161 lines to 32 lines, then\nfrom 46 lines to 33 lines )\n( coqc version 8.6 (May 2017) compiled on May 11 2017 12:23:39 with OCaml\n4.02.3\ncoqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.6,(HEAD\ndetached from 7e992fa) (3b6d89a) *)\nReserved Notation ""'dlet' x .. y := A 'in' b""\n(at level 200, x binder, y binder, b at level 200, format ""'dlet'  x .. y  :=\nA  'in' '//' b"").\nDefinition Let_In {A P} (x : A) (f : forall a : A, P a) : P x := let y := x in\nf y.\nNotation ""'dlet' x .. y := v 'in' f"" := (Let_In (P:=fun _ => _) v (fun x => ..\n(fun y => f) .. )).\nCheck dlet '((x, y)%core : _ * _) := _ in _. (* Anomaly: free_vars_of_pat."
337520110,3368,2014-06-10 17:38:44,"(* File reduced by coq-bug-finder from 7411 lines to 2271 lines., then from 889 lines to 119 lines, then from 76 lines to 19 lines )\nSet Universe Polymorphism.\nSet Primitive Projections.\nRecord PreCategory := { object :> Type; morphism : object -> object -> Type }.\nRecord Functor (C D : PreCategory) :=\n{ object_of :> C -> D;\nmorphism_of : forall s d, morphism C s d -> morphism D (object_of s) (object_of d) }.\nDefinition opposite (C : PreCategory) : PreCategory := @ Build_PreCategory C (fun s d => morphism C d s).\nDefinition opposite' C D (F : Functor C D)\n:= Build_Functor (opposite C) (opposite D)\n(object_of F)\n(fun s d => @ morphism_of C D F s d).\n( Toplevel input, characters 15-191:\nAnomaly: File ""pretyping/reductionops.ml"", line 149, characters 4-10: Assertion failed.\nPlease report. *)"
337550535,5300,2017-03-16 16:46:17,"(* File reduced by coq-bug-finder from original input, then from 702 lines to 358 lines, then from 268 lines to 113 lines, then from 115 lines to 25 lines, then from 578 lines to 112 lines, then from 291 lines to 122 lines, then from 460 lines to 151 lines, then from 1150 lines to 356 lines, then from 1086 lines to 364 lines, then from 3988 lines to 6456 lines, then from 352 lines to 285 lines, then from 546 lines to 120 lines, then from 859 lines to 389 lines, then from 725 lines to 204 lines, then from 285 lines to 214 lines, then from 390 lines to 229 lines, then from 622 lines to 217 lines, then from 666 lines to 255 lines, then from 2020 lines to 257 lines, then from 270 lines to 256 lines, then from 205 lines to 143 lines, then from 157 lines to 153 lines, then from 149 lines to 29 lines, then from 43 lines to 29 lines *)\n(* coqc version 8.6 (December 2016) compiled on Dec 15 2016 15:52:39 with OCaml 4.02.3\n   coqtop version 8.6 (December 2016) *)\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := abstract case proof_admitted.\nModule Type Empty. End Empty.\nModule Export R. End R.\nModule Type FMultisetsOn. Parameter t : Type. End FMultisetsOn.\nModule Make (X : Empty).\n  Record t := {}.\nEnd Make.\nModule M : FMultisetsOn.\n  Module M' := Make R.\n  Definition t := M'.t.\nEnd M."
337521139,3439,2014-07-17 22:22:09,"(* File reduced by coq-bug-finder from original input, then from 3154 lines to 149 lines, then from 89 lines to 55 lines, then from 44 lines to 20 lines *)\nSet Primitive Projections.\nGeneralizable All Variables.\nAxiom IsHSet : Type -> Type.\nExisting Class IsHSet.\nRecord PreCategory := { object :> Type }.\nNotation IsStrictCategory C := (IsHSet (object C)).\nInstance trunc_prod {IsHSet A} {IsHSet B} : IsHSet (A * B) | 100.\nadmit.\nDefined.\nTypeclasses Transparent object.\nDefinition prod (C D : PreCategory) : PreCategory := Build_PreCategory (Datatypes.prod C D).\nGlobal Instance isstrict_category_product `{IsStrictCategory C, IsStrictCategory D} : IsStrictCategory (prod C D).\nProof.\nFail typeclasses eauto."
337521140,3439,2014-07-25 15:43:26,"(* File reduced by coq-bug-finder from original input, then from 7425 lines to 154 lines, then from 116 lines to 20 lines *)\nClass Contr (A : Type) := { center : A }.\nInstance contr_unit : Contr unit | 0 := {| center := tt |}.\nModule non_prim.\nUnset Primitive Projections.\nRecord PreCategory := { object :> Type }.\nLemma foo : Contr (object (@ Build_PreCategory unit)).\nProof.\nsolve [ simpl; typeclasses eauto ] || fail ""goal not solved"".\nUndo.\nsolve [ typeclasses eauto ].\nDefined.\nEnd non_prim.\nModule prim.\nSet Primitive Projections."
337525010,3673,2014-09-28 13:46:01,"Use-case: I inspect coqtop -help to discover option support in coq-bug-finder.  If I make install, update coq, and then make install-coqlight, I'll get this error until I finish building and installing the rest of Coq."
337534451,4218,2015-04-30 18:21:29,"( File reduced by coq-bug-finder from original input, then from 83 lines to 70 lines )\n( coqc version 8.5beta1 (April 2015) compiled on Apr 9 2015 15:39:28 with OCaml 4.01.0\ncoqtop version cagnode13:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (33650e2) *)\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := case proof_admitted.\nRequire Coq.Setoids.Setoid.\nLocal Coercion is_true : bool >-> Sortclass.\nClass StringLike {Char : Type} :=\n{\nString :> Type;\ntake : nat -> String -> String;\ndrop : nat -> String -> String\n}.\nArguments StringLike : clear implicits.\nSection forall_chars."
337530152,3976,2015-02-01 06:39:26,"(* File reduced by coq-bug-finder from original input, then from 184 lines to 86 lines, then from 104 lines to 76 lines )\n( coqc version trunk (January 2015) compiled on Jan 17 2015 21:58:5 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (9e6b28c) *)\nSet Universe Polymorphism.\nModule F_prod_cmp_M.\nAxiom m : let x := Type@ {i} : Type@ {j} in Type@ {i} -> Type@ {j}.\nEnd F_prod_cmp_M.\nModule isequiv_F_prod_cmp_M.\nSet Printing Universes.\nPrint F_prod_cmp_M. (* Module\nF_prod_cmp_M\n:= Struct\nParameter m :\nlet x := Type@ {Var(1)} in Type@ {Var(1)} -> Type@ {Var(0)}.\n(* Top.93"
337527023,3788,2014-11-02 07:49:29,"(* File reduced by coq-bug-finder from original input, then from 7931 lines to 139 lines, then from 119 lines to 32 lines, then from 24 lines to 8 lines )\n( coqc version trunk (September 2014) compiled on Sep 29 2014 14:5:39 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-HoTT,(no branch) (e872655) )\nSet Implicit Arguments.\nGlobal Set Primitive Projections.\nRecord Functor (C D : Type) := { object_of :> forall _ : C, D }.\nAxiom path_functor_uncurried : forall C D (F G : Functor C D) (_ : sigT (fun HO : object_of F = object_of G => Set)), F = G.\nLemma path_functor_uncurried_snd C D F G HO HM\n: (@ path_functor_uncurried C D F G (existT _ HO HM)) = HM. ( Anomaly: Uncaught exception Not_found(_). Please report. *)\nFrom e872655; seems to possibly be fixed in latest trunk?  (Was this known?)"
337524240,3621,2014-09-14 18:42:12,"(* File reduced by coq-bug-finder from original input, then from 16213 lines to 15830 lines, then from 15051 lines to 137 lines, then from 127 lines to 85 lines, then from 67 lines to 19 lines )\n( coqc version trunk (September 2014) compiled on Sep 14 2014 12:57:41 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (9bf62ae) )\nSet Implicit Arguments.\nLocal Set Primitive Projections.\nRecord PreCategory := { object :> Type ; morphism : object -> object -> Type }.\nRecord morphism' (A : PreCategory) (abf a'b'f' : A) := { g : morphism A abf a'b'f' }.\nGoal forall (H : PreCategory) (H4 H5 : H) (H6 H7 : morphism' H H4 H5),\ng H7 = g H6.\nintros.\nmatch goal with\n| [ |- context[?f _ _ _ ?m] ] => idtac\nend. ( Toplevel input, characters 15-80:\nAnomaly: Uncaught exception Invalid_argument(""Array.fold_left2"", _).\nPlease report. *)"
337517874,3239,2014-02-22 00:10:44,"(* File reduced by coq-bug-finder from 1127 lines to 74 lines, then from 85 lines to 38 lines. *)\nRequire Coq.Setoids.Setoid.\nAxiom Comp : Type -> Type.\nAxiom refineEquiv : forall {A B} (old : @ Comp A) (new : @ Comp B), Prop.\nAxiom foo : forall T, T.\nAxiom bar : forall T, T.\nAxiom refineEquiv_split_ex : forall {A B}, @ refineEquiv A B (foo _) (bar _).\nDefinition refineEquiv_split_func_ex {A B} y : @ refineEquiv A B (foo _) y.\nProof.\nsetoid_rewrite refineEquiv_split_ex.\n(* Toplevel input, characters 15-50:\nAnomaly: Uncaught exception Reduction.NotConvertible. Please report. *)\nOccurs in trunk (8089dc9) and in 8.4.\nThe example here is obviously nonsensical, but it originated from what should be valid code."
337518245,3258,2014-03-21 00:50:20,"(* File reduced by coq-bug-finder from 2744 lines to 147 lines, then to 47 lines. *)\nRequire Import Coq.Classes.Morphisms Coq.Classes.RelationClasses Coq.Program.Program Coq.Setoids.Setoid.\nGlobal Set Implicit Arguments.\nHint Extern 0 => apply reflexivity : typeclass_instances.\nInductive Comp : Type -> Type :=\n| Pick : forall A, (A -> Prop) -> Comp A.\nAxiom computes_to : forall A, Comp A -> A -> Prop.\nAxiom refine : forall {A} (old : Comp A) (new : Comp A), Prop.\nGlobal Instance refine_PreOrder A : PreOrder (@ refine A).\nAdmitted.\nAdd Parametric Morphism A\n: (@ Pick A)\nwith signature\n(pointwise_relation _ (flip impl))\n==> (@ refine A)"
337526386,3755,2014-10-20 16:11:31,"(* File reduced by coq-bug-finder from original input, then from 6729 lines to 411 lines, then from 148 lines to 115 lines )\n( coqc version trunk (October 2014) compiled on Oct 16 2014 13:27:5 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (d0da8a7) *)\nRequire Import Coq.Lists.List.\nSet Printing Universes.\nAxiom smem : Type.\nRecord settings := { }.\nSet Implicit Arguments.\nSection machine.\nVariables pc state : Type.\nInductive propX (i := pc) (j := state) : list Type -> Type :=\n| Imply : forall G, propX G -> propX G -> propX G\n| Exists : forall G A, (A -> propX G) -> propX G.\nDefinition PropX := propX nil.\nDefinition spec := state -> PropX."
337526389,3755,2015-01-18 05:04:07,"(* File reduced by coq-bug-finder from original input, then from 6729 lines to\n411 lines, then from 148 lines to 115 lines, then from 99 lines to 70 lines,\nthen from 85 lines to 63 lines, then from 76 lines to 55 lines )\n( coqc version trunk (January 2015) compiled on Jan 17 2015 21:58:5 with OCaml\n4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk\n(9e6b28c) *)\nRequire Import Coq.Lists.List.\nSet Printing Universes.\nRecord settings := { }.\nSet Implicit Arguments.\nSection machine.\nVariables pc state : Type.\nInductive propX (i := pc) (j := state) : list Type -> Type :=\n| Exists : forall G A, (A -> propX G) -> propX G."
337526393,3755,2015-01-18 05:48:50,"(* File reduced by coq-bug-finder from original input, then from 6729 lines to\n411 lines, then from 148 lines to 115 lines, then from 99 lines to 70 lines,\nthen from 85 lines to 63 lines, then from 76 lines to 55 lines, then from 61\nlines to 17 lines )\n( coqc version trunk (January 2015) compiled on Jan 17 2015 21:58:5 with OCaml\n4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk\n(9e6b28c) )\nSet Printing Universes.\nSection param.\nVariable typeD : Set -> Set.\nVariable STex : forall (T : Type) (p : T -> Set), Set.\nDefinition existsEach_cons' v (P : @ sigT _ typeD -> Set) :=\n@ STex _ (fun x => P (@ existT _ _ v x)).\nCheck @ existT _ _ STex STex."
337524889,3665,2014-09-25 16:05:52,"(* File reduced by coq-bug-finder from original input, then from 5449 lines to 44 lines )\n( coqc version trunk (September 2014) compiled on Sep 25 2014 2:53:46 with OCaml 4.01.0\ncoqtop version trunk (September 2014) )\nSet Primitive Projections.\nAxiom IsHSet : Type -> Type.\nRecord hSet := BuildhSet {setT:> Type; iss :> IsHSet setT}.\nCanonical Structure default_HSet := fun T P => (@ BuildhSet T P).\nGoal forall (z : hSet) (T0 : Type -> Type),\n(forall (A : Type) (P : T0 A -> Type) (aa : T0 A), P aa) ->\nforall x0 : setT z, Set.\nclear; intros z T H.\nTimeout 1 refine (H _ _). ( Timeout! *)"
337522004,3487,2014-08-05 13:37:40,"(* File reduced by coq-bug-finder from original input, then from 14440 lines to 1034 lines, then from 1370 lines to 669 lines, then from 647 lines to 353 lines, then from 250 lines to 178 lines, then from 130 lines to 84 lines, then from 84 lines to 40 lines )\nNotation bar := $(exact I)$.\nNotation foo := bar (only parsing).\nClass baz := { x : False }.\nInstance: baz.\nAdmitted.\nDefinition baz0 := ((_ : baz) = (_ : baz)).\nDefinition foo1 := (foo = foo).\nDefinition baz1 := prod ((_ : baz) = (_ : baz)) (foo = foo).\n( Toplevel input, characters 26-27:\nError: Cannot infer this placeholder.\nCould not find an instance for ""baz"". *)"
337521095,3435,2014-07-17 10:23:45,"(* File reduced by coq-bug-finder from original input, then from 3171 lines to 131 lines, then from 114 lines to 69 lines, then from 78 lines to 14 lines )\nSet Primitive Projections.\nSet Implicit Arguments.\nRecord PreCategory := { object :> Type ; morphism : object -> object -> Type }.\nArguments morphism !C s d : rename.\nGoal forall (C D : PreCategory) (fst fst0 : object C) (snd snd0 : object D) (fst1 : morphism C fst fst0),\n(@ pair (morphism C fst fst0) (morphism D snd snd0) fst1) = (@ pair (morphism C fst fst0) (morphism D snd snd0) fst1).\ntrivial. ( Toplevel input, characters 0-8:\nAnomaly: Uncaught exception Invalid_argument(""List.nth"", _). Please report. *)"
337551981,5402,2017-03-15 23:26:13,"( File reduced by coq-bug-finder from original input, then from 1205 lines to\n60 lines, then from 365 lines to 60 lines, then from 2861 lines to 62 lines,\nthen from 148 lines to 36 lines, then from 162 lines to 61 lines, then from 68\nlines to 15 lines, then from 948 lines to 331 lines )\n( coqc version trunk (March 2017) compiled on Mar 13 2017 15:45:4 with OCaml\n4.04.0\ncoqtop version cauchy.local:/Users/tchajed/code/sw/coq-trunk,trunk\n(b548929) *)\nAxiom T : Type.\nAxiom property : T -> Prop.\nAxiom xform : T -> T.\nAxiom property_xform : forall x, property (xform x).\nTheorem foo (H:True) : exists x, property x /\ property x.\nProof.\neexists; split."
337525391,3698,2014-10-07 05:57:35,"(* File reduced by coq-bug-finder from original input, then from 5479 lines to 4682 lines, then from 4214 lines to 86 lines, then from 60 lines to 25 lines )\n( coqc version trunk (October 2014) compiled on Oct 1 2014 18:13:54 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (6884680) )\nSet Primitive Projections.\nNotation ""( x ; y )"" := (existT _ x y) : fibration_scope.\nOpen Scope fibration_scope.\nNotation pr1 := projT1.\nNotation ""x .1"" := (pr1 x) (at level 3, format ""x '.1'"") : fibration_scope.\nAxiom ap : forall {A B:Type} (f:A -> B) {x y:A} (p:x = y), f x = f y.\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A }.\nRecord Equiv A B := { equiv_fun :> A -> B ; equiv_isequiv :> IsEquiv equiv_fun }.\nGlobal Existing Instance equiv_isequiv.\nNotation ""A <> B"" := (Equiv A B) (at level 85) : equiv_scope.\nNotation ""f ^-1"" := (@ equiv_inv _ _ f _) (at level 3, format ""f '^-1'"") : equiv_scope.\nAxiom IsHSet : Type -> Type."
337525392,3698,2014-10-10 03:10:06,"(* File reduced by coq-bug-finder from original input, then from 19803 lines to 9107 lines, then from 8545 lines to 207 lines, then from 204 lines to 23 lines )\n( coqc version trunk (October 2014) compiled on Oct 8 2014 13:38:17 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (335cf28) )\nSet Primitive Projections.\nAxiom IsHSet : Type -> Type.\nRecord hSet := BuildhSet {setT:> Type; iss :> IsHSet setT}.\nCanonical Structure default_HSet:= fun T P => (@ BuildhSet T P).\nGoal forall (x y : hSet) (m : x -> y) (equiv_inv0 : y -> x),\n(forall x : y, m (equiv_inv0 x) = x) ->\n(forall x0 : x, equiv_inv0 (m x0) = x0) ->\nforall x0 : x, equiv_inv0 (m x0) = x0.\nintros x y m equiv_inv0 eisretr0 eissect0 x0.\napply eissect0.\nUndo.\nTimeout 1 try apply eisretr0. ( stack overflow *)"
337523852,3599,2014-09-08 21:55:53,"(* File reduced by coq-bug-finder from original input, then from 6391 lines to 168 lines, then from 131 lines to 34 lines )\n( coqc version trunk (September 2014) compiled on Sep 8 2014 15:21:24 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (51d38d0) *)\nSet Implicit Arguments.\nRecord PreCategory :=\n{ object :> Type;\nmorphism : object -> object -> Type;\nidentity : forall x, morphism x x }.\nDefinition indiscrete_category (X : Type) : PreCategory := @ Build_PreCategory X (fun _ _ => unit) (fun _ => tt).\nSection NonPrim.\nRecord Functor (C D : PreCategory) :=\n{ object_of :> C -> D;\nmorphism_of : forall s d, morphism C s d -> morphism D (object_of s) (object_of d);\nidentity_of : forall x, morphism_of _ _ (identity _ x) = identity _ (object_of x) }.\nGoal (forall (C : PreCategory) (X : Functor (indiscrete_category unit) C),"
337534790,4240,2015-05-19 05:00:51,"( File reduced by coq-bug-finder from original input, then from 44 lines to 31 lines, then from 192 lines to 178 lines, then from 67 lines to 54 lines )\n( coqc version 8.5beta2 (May 2015) compiled on May 18 2015 3:21:19 with OCaml 4.01.0\ncoqtop version nickolai-coqdev:/home/ubuntu/coq,v8.5 (b07c8f1) *)\nRequire Coq.Arith.Div2.\nImport Coq.Arith.Div2.\nSet Implicit Arguments.\nInductive word : nat -> Set :=\n| WO : word O\n| WS : bool -> forall n, word n -> word (S n).\nFixpoint wordToNat sz (w : word sz) : nat :=\nmatch w with\n| WO => O\n| WS false w' => (wordToNat w') * 2\n| WS true w' => S (wordToNat w' * 2)\nend."
337521379,3451,2014-07-22 19:40:20,"(* File reduced by coq-bug-finder from original input, then from 13503 lines to 824 lines, then from 731 lines to 741 lines, then from 754 lines to 586 lines, then from 600 lines to 309 lines, then from 311 lines to 26 lines )\nClass foo : Set := {}.\nInstance: foo := {}.\nAxiom T : Set.\nGoal exists (p : prod Set foo), T = fst p.\nProof.\nintros.\neexists.\nchange T with (fst (T, (_ : foo))).\n( Anomaly: undefined_evars_of_term: evar not found. Please report. *)"
337521670,3469,2014-07-30 11:13:06,"(* File reduced by coq-bug-finder from original input, then from 538 lines to 31 lines *)\nOpen Scope type_scope.\nGlobal Set Primitive Projections.\nSet Implicit Arguments.\nRecord sig (A : Type) (P : A -> Type) := exist { proj1_sig : A ; proj2_sig : P proj1_sig }.\nNotation sigT := sig (only parsing).\nNotation ""{ x : A  & P }"" := (sigT (fun x:A => P)) : type_scope.\nNotation projT1 := proj1_sig (only parsing).\nNotation projT2 := proj2_sig (only parsing).\nVariables X : Type.\nVariable R : X -> X -> Type.\nLemma dependent_choice :\n(forall x:X, {y : _ & R x y}) ->\nforall x0, {f : nat -> X & (f O = x0) * (forall n, R (f n) (f (S n)))}.\nProof."
337520181,3373,2014-06-10 22:35:00,"(* File reduced by coq-bug-finder from original input, then from 5968 lines to 11933 lines, then from 11239 lines to 11231 lines, the\nn from 10365 lines to 446 lines, then from 456 lines to 379 lines, then from 391 lines to 373 lines, then from 369 lines to 351 lines\n, then from 350 lines to 340 lines, then from 348 lines to 320 lines, then from 328 lines to 302 lines, then from 332 lines to 21 lin\nes )\nSet Universe Polymorphism.\nAxiom admit : forall {T}, T.\nDefinition UU := Set.\nDefinition UU' := Type.\nDefinition hSet:= sigT (fun X : UU' => admit) .\nDefinition pr1hSet:= @ projT1 UU (fun X : UU' => admit) : hSet -> Type.\nCoercion pr1hSet: hSet >-> Sortclass.\nAxiom binop : UU -> Type.\nAxiom setwithbinop : Type.\nDefinition pr1setwithbinop : setwithbinop -> hSet.\nexact ( @ projT1 _ ( fun X : hSet@ {i j} => binop X ) )."
337520189,3373,2014-06-20 13:41:54,"(* File reduced by coq-bug-finder from original input, then from 5968 lines to 11933 lines, then from 11239 lines to 11231 lines, then from 10365 lines to 446 lines, then from 456 lines to 379 lines, then from 391 lines to 373 lines, then from 369 lines to 351 lines, then from 350 lines to 340 lines, then from 348 lines to 320 lines, then from 328 lines to 302 lines, then from 332 lines to 21 lines *)\nSet Universe Polymorphism.\nAxiom admit : forall {T}, T.\nDefinition UU := Set.\nDefinition UU' := Type.\nDefinition hSet:= sigT (fun X : UU' => admit) .\nDefinition pr1hSet:= @ projT1 UU (fun X : UU' => admit) : hSet -> Type.\nCoercion pr1hSet: hSet >-> Sortclass.\nAxiom binop : UU -> Type.\nAxiom setwithbinop : Type.\nDefinition pr1setwithbinop : setwithbinop -> hSet.\nGoal True.\npose (( @ projT1 _ ( fun X : hSet@ {i j} => binop X ) ) : _ -> hSet).\nIt looks like hSet has gained an extra universe since then, though?"
337520192,3373,2014-06-20 18:36:01,"(* File reduced by coq-bug-finder from original input, then from 5968 lines to\n11933 lines, then from 11239 lines to 11231 lines, then from 10365 lines to 446\nlines, then from 456 lines to 379 lines, then from 391 lines to 373 lines, then\nfrom 369 lines to 351 lines, then from 350 lines to 340 lines, then from 348\nlines to 320 lines, then from 328 lines to 302 lines, then from 332 lines to 21\nlines )\nSet Universe Polymorphism.\nModule short.\nRecord foo := { bar : Type }.\nCoercion baz (x : foo@ {Set}) : Set := bar x.\nGoal True.\nProof.\nFail pose ({| bar := Set |} : Type). ( check that it fails )\ntry pose ({| bar := Set |} : Type). ( Anomaly: apply_coercion_args: mismatch between arguments and coercion.\nPlease report. *)"
337532275,4101,2015-03-03 02:35:53,"(* File reduced by coq-bug-finder from original input, then from 10940 lines to 152 lines, then from 509 lines to 163 lines, then from 178 lines to 66 lines )\n( coqc version 8.5beta1 (March 2015) compiled on Mar 2 2015 18:53:10 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (e77f178) *)\nGlobal Set Primitive Projections.\nSet Implicit Arguments.\nRecord sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\nAxiom path_forall : forall {A : Type} {P : A -> Type} (f g : forall x : A, P x),\n(forall x, f x = g x) -> f = g.\nLemma sigT_obj_eq\n: forall (T : Type) (T0 : T -> Type)\n(s s0 : forall s : sigT T0,\nsigT (fun _ : T0 (projT1 s) => unit) ->\nsigT (fun _ : T0 (projT1 s) => unit)),\ns0 = s.\nProof."
337526547,3757,2014-10-21 20:14:27,"(* File reduced by coq-bug-finder from original input, then from 2980 lines to 89 lines, then from 77 lines to 43 lines )\n( coqc version trunk (October 2014) compiled on Oct 21 2014 14:32:3 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (eb9c2c4) )\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A ; eisretr : forall x, f (equiv_inv x) = x }.\nClass Contr_internal (A : Type) := { center : A ; contr : (forall y : A, center = y) }.\nArguments center A {}.\nDefinition Contr := Contr_internal.\nExisting Class Contr.\nHint Extern 0 => progress change Contr_internal with Contr in * : typeclass_instances.\nDefinition equiv_contr_unit {A} `{Contr A} : IsEquiv (fun ( : A) => tt).\nProof.\nrefine (Build_IsEquiv _ _ _\n(fun (_ : unit) => center A)\n_).\nintros []; constructor. ( Error: No such goal *)"
337550874,5322,2017-01-22 05:34:04,"( File reduced by coq-bug-finder from original input, then from 440 lines to\n147 lines, then from 452 lines to 178 lines, then from 204 lines to 76 lines,\nthen from 102 lines to 44 lines, then from 482 lines to 129 lines, then from\n223 lines to 132 lines, then from 237 lines to 134 lines, then from 183 lines\nto 135 lines, then from 149 lines to 135 lines, then from 112 lines to 46\nlines, then from 60 lines to 47 lines, then from 54 lines to 24 lines, then\nfrom 38 lines to 25 lines )\n( coqc version 8.6rc1 (December 2016) compiled on Dec 8 2016 13:43:59 with\nOCaml 4.02.3\ncoqtop version 8.6rc1 (December 2016) *)\nInductive flat_type := Unit | Prod (A B : flat_type).\nInductive exprf (op : flat_type -> flat_type -> Type) {var : Type} : flat_type\n-> Type :=\n| Op {t1 tR} (opc : op t1 tR) (args : exprf op t1) : exprf op tR.\nInductive op : flat_type -> flat_type -> Type := a : op Unit Unit."
337525730,3718,2014-10-11 04:34:36,"(* File reduced by coq-bug-finder from original input, then from 906 lines to 14 lines, then from 34 lines to 23 lines )\n( coqc version trunk (October 2014) compiled on Oct 8 2014 13:38:17 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (335cf28) )\nRequire Import Coq.Classes.EquivDec.\nGoal forall (e : option bool),\nmatch e return option bool with\n| Some f => None\n| None => None\nend <> None -> False.\nclear; intros e H0.\nmatch goal with\n| [ H : match ?X with\n| Some _ => _ | None => _\nend <> None |- _ ]\n=> pose X"
337543537,4818,2016-06-14 00:45:55,"( File reduced by coq-bug-finder from original input, then from 391 lines to 77 lines, then from 857 lines to 119 lines, then from 1584 lines to 126 lines, then from 362 lines to 135 lines, then from 149 lines to 135 lines )\n( coqc version 8.5pl1 (June 2016) compiled on Jun 9 2016 17:27:17 with OCaml 4.02.3\ncoqtop version 8.5pl1 (June 2016) *)\nSet Universe Polymorphism.\nInductive GCov (I : Type) : Type := | Foo : I -> GCov I.\nSection Product.\nVariables S IS : Type.\nVariable locS : IS -> True.\nGoal GCov (IS * S) -> GCov IS.\nintros X0. induction X0; intros.\ndestruct i.\nspecialize (locS i).\nclear -locS.\ndestruct locS.\nAdmitted."
337526985,3786,2014-10-30 06:00:14,"(* File reduced by coq-bug-finder from original input, then from 9432 lines to 1348 lines, then from 1208 lines to 805 lines, then from 784 lines to 404 lines, then from 403 lines to 213 lines, then from 226 lines to 59 lines, then from 62 lines to 36 lines )\n( coqc version 8.4pl4 (August 2014) compiled on Aug 19 2014 14:07:28 with OCaml 4.01.0\ncoqtop version 8.4pl4 (August 2014) )\nRequire Coq.Lists.List.\nRequire Coq.Sets.Ensembles.\nImport Coq.Sets.Ensembles.\nGlobal Set Implicit Arguments.\nDelimit Scope comp_scope with comp.\nInductive Comp : Type -> Type :=\n| Return : forall A, A -> Comp A\n| Bind : forall A B, Comp A -> (A -> Comp B) -> Comp B\n| Pick : forall A, Ensemble A -> Comp A.\nNotation ret := Return.\nNotation ""x <- y ; z"" := (Bind y%comp (fun x => z%comp))\n(at level 81, right associativity,"
337555211,5608,2017-06-16 02:53:02,"( File reduced by coq-bug-finder from original input, then from 126 lines to\n15 lines, then from 653 lines to 15 lines, then from 195 lines to 37 lines,\nthen from 223 lines to 89 lines, then from 237 lines to 89 lines, then from 105\nlines to 90 lines )\n( coqc version 8.6 (June 2017) compiled on Jun 15 2017 12:8:43 with OCaml\n4.02.3\ncoqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.6,(HEAD\ndetached from 7e992fa) (ce1e1db) *)\nReserved Notation ""'slet' x .. y := A 'in' b""\n(at level 200, x binder, y binder, b at level 200, format ""'slet'  x\n.. y  :=  A  'in' '//' b"").\nReserved Notation ""T x [1] = { A } ; 'return' ( b0 , b1 , .. , b2 )"" (at level\n200, format ""T  x [1]  =  { A } ; '//' 'return'  ( b0 ,  b1 ,  .. ,  b2 )"").\nDelimit Scope ctype_scope with ctype.\nLocal Open Scope ctype_scope."
337521130,3438,2014-07-17 22:16:29,"(* File reduced by coq-bug-finder from original input, then from 4557 lines to 83 lines, then from 77 lines to 11 lines )\nSet Universe Polymorphism.\nSet Primitive Projections.\nSet Implicit Arguments.\nRecord sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\nNotation ""( x ; y )"" := (existT _ x y).\nAxiom IsHSet : Type -> Type.\nRecord hSet := BuildhSet {setT:> Type; iss :> IsHSet setT}.\nCanonical Structure default_HSet:= fun T P => (@ BuildhSet T P).\nGoal hSet -> sigT (fun x : Type => IsHSet x).\nexact (fun x => (setT x; iss x)).\nUndo.\nTimeout 1 exact (fun x => existT IsHSet (@ setT x) (@ iss x)). ( Timeout! *)"
337521084,3434,2014-07-17 09:35:48,"(* File reduced by coq-bug-finder from original input, then from 3160 lines to 84 lines, then from 69 lines to 15 lines )\nSet Primitive Projections.\nSet Implicit Arguments.\nModule Export Datatypes.\nRecord prod A B := pair { fst : A ; snd : B }.\nEnd Datatypes.\nDelimit Scope category_scope with category.\nRecord PreCategory := { object :> Type ; morphism : object -> object -> Type }.\nArguments morphism !C%category s d : rename.\nGoal forall (C D : PreCategory), forall (a b : prod (object C) (object D))\n(f : prod (morphism C (fst a) (fst b)) (morphism D (snd a) (snd b))),\nf = f.\nintros ? ?.\ndo 9 (lazy iota delta [Datatypes.fst Datatypes.snd] || intros [] || intro).\nintros []."
337521015,3430,2014-07-16 22:03:38,"(* File reduced by coq-bug-finder from original input, then from 2809 lines to 39 lines )\nSet Primitive Projections.\nModule Export foo.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nEnd foo.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with idpath => idpath end.\nAxiom path_prod : forall {A B : Type} (z z' : prod A B), (fst z = fst z') -> (snd z = snd z') -> (z = z').\nNotation fst := (@ fst _ _).\nNotation snd := (@ snd _ _).\nSet Printing All.\nTimeout 2 Definition ap_fst_path_prod {A B : Type} {z z' : prod A B} (p : @ paths _ (fst z) (fst z')) (q : snd z = snd z')\n: ap fst (path_prod _ _ p q) = p.\n( Timeout! *)"
337518786,3289,2014-04-21 01:24:46,"(* File reduced by coq-bug-finder from original input, then from 1829 lines to 37 lines, then from 47 lines to 18 lines *)\nClass Contr_internal (A : Type) :=\nBuildContr { center : A ;\ncontr : (forall y : A, True) }.\nClass Contr A := Contr_is_contr : Contr_internal A.\nInductive Unit : Set := tt.\nInstance contr_unit : Contr Unit | 0 :=\nlet x := {|\ncenter := tt;\ncontr := fun t : Unit => I\n|} in x. (* success *)\nInstance contr_unit' : Contr Unit | 0 :=\n{|\ncenter := tt;\ncontr := fun t : Unit => I"
337517737,3230,2014-02-07 02:40:30,"With the help of coq-bug-finder (https://github.com/JasonGross/coq-bug-finder), I managed to reduce your example to the following.\nStructure type : Type := Pack { ob : Type }.\nPolymorphic Record category := { foo : Type }.\nCanonical Structure FuncComp := Pack category.\nAxiom C : category.\nCheck (C : ob FuncComp).\nIt does indeed seem to be an issue with canonical structures, as changing [Canonical Structure] to [Definition] makes the error go away.  Perhaps canonical structures are not declared transparent to the unification engine (or one of them?  Because the [unify] tactic knows to unify them...).  Actually, you know what, I bet Matthieu forgot to tell Coq that [Canonical Structure] is a kind of definition that universe polymorphism should be applied to (or that universes should be tracked with, or that universes should be refreshed with, or something); so the universes of [FuncComp] probably live in a different place than the rest of the universes, and then things go wrong.  At least that's my guess.  But replacing [Canonical Structure] with [Monomorphic Definition] makes the error go away, so it's probably a bit more subtle than that.\nMy category theory library doesn't use canonical structures, so I'm not surprised I haven't hit this particular bug.\nTangentially, is your source code publicly available?  Are you interested in adding it to http://mathoverflow.net/questions/152497/formalizations-of-category-theory-in-proof-assistants ?"
337525481,3703,2014-10-07 18:25:22,"(* File reduced by coq-bug-finder from original input, then from 6746 lines to 4190 lines, then from 29 lines to 18 lines, then fro\nm 30 lines to 19 lines )\n( coqc version trunk (October 2014) compiled on Oct 7 2014 12:42:41 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (2313bde) *)\nRecord PreCategory := { identity : forall x, x -> x }.\nDefinition set_cat : PreCategory := @ Build_PreCategory (fun T x => x).\nModule UnKeyed.\nGlobal Unset Keyed Unification.\nGoal forall (T : Type) (g0 g1 : T) (k : T) (H' : forall x : T, k = @ identity set_cat T x),\n((fun x : T => x) g0) = ((fun x : T => x) g1).\nintros T g0 g1 k H'.\nchange (identity _ _) with (fun y : T => y) in H';\nrewrite <- H' || fail ""too early"".\nUndo.\nrewrite <- H'."
337524911,3667,2014-09-26 12:49:21,"(* File reduced by coq-bug-finder from original input, then from 7140 lines to 221 lines, then from 192 lines to 143 lines, then from 132 lines to 85 lines, then from 82 lines to 29 lines )\n( coqc version trunk (September 2014) compiled on Sep 25 2014 2:53:46 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (bec7e09) *)\nSet Primitive Projections.\nAxiom ap10 : forall {A B} {f g:A->B} (h:f=g) x, f x = g x.\nAxiom IsHSet : Type -> Type.\nRecord hSet := BuildhSet {setT:> Type; iss :> IsHSet setT}.\nCanonical Structure default_HSet:= fun T P => (@ BuildhSet T P).\nRecord PreCategory := { object :> Type ; morphism : object -> object -> Type }.\nRecord Functor (C D : PreCategory) :=\n{ object_of :> C -> D;\nmorphism_of : forall s d, morphism C s d\n-> morphism D (object_of s) (object_of d) }.\nSet Implicit Arguments.\nRecord NaturalTransformation C D (F G : Functor C D) :="
337524490,3638,2014-09-18 04:50:05,"(* File reduced by coq-bug-finder from original input, then from 7593 lines to 243 lines, then from 256 lines to 102 lines, then from 104 lines to 28 lines )\n( coqc version trunk (September 2014) compiled on Sep 17 2014 0:22:30 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (d34e1ee) )\nSet Primitive Projections.\nSet Implicit Arguments.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nNotation ""x * y"" := (prod x y) : type_scope.\nNotation ""( x , y , .. , z )"" := (pair .. (pair x y) .. z) : core_scope.\nClass UnitSubuniverse := { O : Type -> Type ; O_unit : forall T, T -> O T }.\nClass ReflectiveSubuniverse := { rsubu_usubu : UnitSubuniverse ; O_rectnd : forall {P Q : Type} (f : P -> Q), O P -> Q }.\nGlobal Existing Instance rsubu_usubu.\nContext {subU : ReflectiveSubuniverse}.\nGoal forall (A B : Type) (x : O A * O B) (x0 : B),\n{ g : _ & O_rectnd (fun z : A * B => (O_unit (fst z), O_unit (snd z)))\n(O_rectnd (fun a : A => O_unit (a, x0)) (fst x)) ="
337524231,3620,2014-09-14 18:04:45,"(* File reduced by coq-bug-finder from original input, then from 7386 lines to 204 lines, then from 170 lines to 45 lines, then from 36 lines to 22 lines )\n( coqc version trunk (September 2014) compiled on Sep 14 2014 12:57:41 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (9bf62ae) *)\nSet Universe Polymorphism.\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A }.\nAxiom IsHProp : Type -> Type.\nNotation IsHSet T := (forall a b : T, IsHProp (a = b)).\nAxiom trunc_equiv : forall {A B} (f : A -> B) {IsHProp A} {IsEquiv A B f}, IsHProp B. Record PreCategory := { object :> Type }. Class Isomorphic {C : PreCategory} (s d : C) := {}. Axiom idtoiso : forall (C : PreCategory) (x y : C) (H : x = y), Isomorphic x y. Notation IsCategory C := (forall s d : object C, IsEquiv (@ idtoiso C s d)). Definition Book_9_1_15 A {H : IsCategory A}\n: IsHSet (object A)\n-> (forall a b, IsHProp (@ Isomorphic A a b)).\nProof.\nintros H' a b.\neapply trunc_equiv.\n\nrefine (H' a b) || fail ""bad""."
337523665,3587,2014-09-06 22:16:09,"(* File reduced by coq-bug-finder from original input, then from 10805 lines to 729 lines, then from 790 lines to 288 lines, then fro\nm 348 lines to 17 lines )\n( coqc version trunk (September 2014) compiled on Sep 6 2014 6:15:6 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (3ea6d68) *)\nModule NonPrim.\nRecord sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\nArguments projT1 {_ } _ / .\nArguments existT {} _ _ _.\nAxiom f : sigT (fun x => x) -> Type.\nAxiom foo : forall x y, f (existT _ x y) = x.\nGoal forall x y, f (existT _ x y) = x.\nintros.\nrewrite foo.\nmatch goal with\n| [ |- context[projT1 (existT _ ?a ?b)] ] => fail 1 ""still a projT1"""
337523193,3563,2014-09-01 19:58:25,"(* File reduced by coq-bug-finder from original input, then from 11716 lines to 11295 lines, then from 10518 lines to 21 lines, then \nfrom 37 lines to 21 lines )\n( coqc version trunk (August 2014) compiled on Aug 31 2014 10:12:32 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (437b91a) )\nSet Primitive Projections.\nRecord prod A B := pair { fst : A ; snd : B }.\nArguments pair {A B} _ _.\nArguments fst {A B} _ / .\nArguments snd {A B} _ / .\nNotation ""x * y"" := (prod x y) : type_scope.\nNotation ""( x , y , .. , z )"" := (pair .. (pair x y) .. z) : core_scope.\nAxiom transport : forall {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x), P y.\nGoal forall (H H0 H1 : Type) (H2 : H1) (H3 : H1 -> H * H0)\n(H4 : (fun c : H1 => (fst (H3 c), snd (H3 c))%core) =\nH3) (H5 : H -> Type) (H6 H7 : H5 (fst (H3 H2))),"
337523165,3561,2014-09-01 04:30:04,"(* File reduced by coq-bug-finder from original input, then from 6343 lines to 2362 lines, then from 2115 lines to 303 lines, then from 321 lines to 90 lines, then from 95 lines to 41 lines )\n( coqc version trunk (August 2014) compiled on Aug 31 2014 10:12:32 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (437b91a) )\nSet Primitive Projections.\nSet Implicit Arguments.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nAxiom transport : forall {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x), P y.\nGoal forall (H0 H2 : Type) x p,\n@ transport (prod H0 H2)\n(fun GO : prod H0 H2 => x (fst GO)) = p.\nmatch goal with\n| [ |- context[?f ?x] ]\n=> rewrite (@ ap_transport _ P _ _ _ p (fun _ => f) z)"
337530135,3975,2015-02-01 06:25:51,"(* File reduced by coq-bug-finder from original input, then from 178 lines to 132 lines, then from 148 lines to 73 lines, then from 80 lines to 11 lines )\n( coqc version trunk (January 2015) compiled on Jan 17 2015 21:58:5 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (9e6b28c) *)\nModule Type TypeM.\nEnd TypeM.\nModule Type FunctionM0 (XM : TypeM).\nEnd FunctionM0.\nModule Type FunctionM (XM : TypeM).\nPrint FunctionM0. (* Anomaly: XM already exists. Please report. *)"
337529586,3943,2015-01-22 18:53:25,"(* File reduced by coq-bug-finder from original input, then from 9492 lines to 119 lines )\n( coqc version 8.5beta1 (January 2015) compiled on Jan 18 2015 7:27:36 with OCaml 3.12.1\ncoqtop version 8.5beta1 (January 2015) *)\nSet Typeclasses Dependency Order.\nInductive paths {A : Type} (a : A) : A -> Type :=\nidpath : paths a a.\nArguments idpath {A a} , [A] a.\nNotation ""x = y"" := (@ paths _ x y) : type_scope.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y\n:= match p with idpath => idpath end.\nSet Implicit Arguments.\nDelimit Scope morphism_scope with morphism.\nDelimit Scope category_scope with category.\nDelimit Scope object_scope with object.\nRecord PreCategory := Build_PreCategory' {"
337523097,3557,2014-08-31 18:37:34,"(* File reduced by coq-bug-finder from original input, then from 8669 lines to 91 lines, then from 51 lines to 34 lines )\n( coqc version trunk (August 2014) compiled on Aug 31 2014 10:12:32 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (437b91a) )\nClass Contr_internal (A : Type) := { center : A }.\nArguments center A {}.\nInductive trunc_index := minus_two | trunc_S ( : trunc_index).\nFixpoint IsTrunc_internal (n : trunc_index) (A : Type) : Type :=\nmatch n with\n| minus_two => Contr_internal A\n| trunc_S n' => forall (x y : A), IsTrunc_internal n' (x = y)\nend.\nClass IsTrunc (n : trunc_index) (A : Type) : Type := Trunc_is_trunc : IsTrunc_internal n A.\nNotation Contr := (IsTrunc minus_two).\nHint Extern 0 => progress change Contr_internal with Contr in * : typeclass_instances.\nNotation ""!"" := (fun _ => center _)."
337533333,4145,2015-03-22 16:04:38,"(* File reduced by coq-bug-finder from original input, then from 2964 lines to 112 lines, then from 112 lines to 90 lines )\n( coqc version 8.5beta1 (March 2015) compiled on Mar 15 2015 16:24:54 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (1b3759e) *)\nRequire Coq.Lists.List.\nGlobal Set Implicit Arguments.\nImport Coq.Lists.List.\nClass IndexBound {A : Set} (a : A) (Bound : list A) :=\n  { ibound :> nat;\n    boundi : nth_error Bound ibound = Some a}.\nGlobal Arguments ibound {A} [a Bound] _ .\nGlobal Arguments boundi {A} [a Bound] _.\nRecord BoundedIndex {A : Set} (Bound : list A) :=\n  { bindex : A;\n    indexb :> IndexBound bindex Bound }.\n"
337529096,3908,2015-01-10 16:18:06,"( File reduced by coq-bug-finder from original input, then from 8235 lines to 5893 lines, then from 5575 lines to 74 lines, then from 503 lines to 37 lines )\n( coqc version trunk (January 2015) compiled on Jan 4 2015 19:26:10 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (c146a31) )\nReserved Notation ""x -> y"" (at level 99, right associativity, y at level 200).\nReserved Notation ""x = y"" (at level 70, no associativity).\nReserved Notation ""{ x : A  & P }"" (at level 0, x at level 99).\nOpen Scope type_scope.\nNotation ""A -> B"" := (forall (_ : A), B) : type_scope.\nSet Implicit Arguments.\nRecord sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\nNotation ""{ x : A  & P }"" := (sigT (fun x:A => P)) : type_scope.\nNotation ""( x ; y )"" := (existT _ x y) : fibration_scope.\nOpen Scope fibration_scope.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A ; eisretr : forall x, f (equiv_inv x) = x }."
337523648,3586,2014-09-06 21:30:06,"(* File reduced by coq-bug-finder from original input, then from 6074 lines to 4194 lines, then from 3673 lines to 40 lines, then from 60 lines to 15 lines )\n( coqc version trunk (September 2014) compiled on Sep 6 2014 6:15:6 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (3ea6d68) )\nSet Record Elimination Schemes.\nLocal Set Primitive Projections.\nRecord hProp := hp { hproptype :> Type }.\nRecord ReflectiveSubuniverse :=\n{ in_subuniverse : Type -> hProp ;\nSubuniverseType := {T : Type & (in_subuniverse) T} ;\nto_O : Type -> SubuniverseType }.\n( Toplevel input, characters 0-163:\nError: Illegal application:\nThe term ""f"" of type\n""forall in_subuniverse : Type -> hProp,\nlet SubuniverseType := {T : Type & in_subuniverse T} in"
337536735,4361,2015-10-07 20:12:52,"(* File reduced by coq-bug-finder from original input, then from 273 lines to 246 lines, then from 265 lines to 258 lines, then from 242 lines to 198 lines, then from 206 lines to 100 lines\n, then from 74 lines to 42 lines )\n( coqc version 8.5beta2 (October 2015) compiled on Oct 2 2015 13:24:5 with OCaml 4.01.0\ncoqtop version cagnode13:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (beedcce) )\nRequire Coq.FSets.FMapAVL.\nAxiom label : Set.\nAxiom W : Set.\nModule Export LabelKey.\nDefinition t := label.\nDefinition eq : t -> t -> Prop := @ eq t.\nAxiom lt : forall (l1 l2 : label), Prop.\nAxiom eq_refl : forall x : t, eq x x.\nAxiom eq_sym : forall x y : t, eq x y -> eq y x.\nAxiom eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\nAxiom lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z."
337532744,4121,2015-03-12 19:42:32,"( File reduced by coq-bug-finder from original input, then from 830 lines to 47 lines, then from 25 lines to 11 lines )\n( coqc version 8.5beta1 (March 2015) compiled on Mar 11 2015 18:51:36 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (8dbfee5) *)\nSet Universe Polymorphism.\nClass Contr_internal (A : Type) := BuildContr { center : A }.\nArguments center A {_}.\nClass Contr (A : Type) : Type := Contr_is_trunc : Contr_internal A.\nHint Extern 0 => progress change Contr_internal with Contr in * : typeclass_instances.\nDefinition contr_paths_contr0 {A} {Contr A} : Contr A := {| center := center A |}. Instance contr_paths_contr1 {A} {Contr A} : Contr A := {| center := center A |}.\nCheck @ contr_paths_contr0@ {i}.\nCheck @ contr_paths_contr1@ {i}. (* Error: Universe instance should have length 2 )\n(* It should have length 1, just like contr_paths_contr0 *)"
337522725,3531,2014-08-21 20:19:35,"(* File reduced by coq-bug-finder from original input, then from 270 lines to 198 lines, then from 178 lines to 82 lines, then from 88 lines to 59 lines )\n( coqc version trunk (August 2014) compiled on Aug 19 2014 14:40:15 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (56ece74) )\nRequire Import Coq.Lists.List.\nSet Implicit Arguments.\nDefinition mem := nat -> option nat.\nDefinition pred := mem -> Prop.\nDelimit Scope pred_scope with pred.\nDefinition exis A (p : A -> pred) : pred := fun m => exists x, p x m.\nNotation ""'exists' x .. y , p"" := (exis (fun x => .. (exis (fun y => p)) ..)) : pred_scope.\nDefinition emp : pred := fun m => forall a, m a = None.\nDefinition lift_empty (P : Prop) : pred := fun m => P /\ forall a, m a = None.\nNotation ""[[ P ]]"" := (lift_empty P) : pred_scope.\nDefinition pimpl (p q : pred) := forall m, p m -> q m.\nNotation ""p ==> q"" := (pimpl p%pred q%pred) (right associativity, at level 90)."
337541616,4673,2016-04-17 01:40:10,"( File reduced by coq-bug-finder from original input, then from 2407 lines to 22 lines, then from 528 lines to 35 lines, then from 331 lines to 42 lines, then from 56 lines to 42 lines, then from 63 lines to 46 lines, then from 60 lines to 46 lines )\n( coqc version 8.5 (February 2016) compiled on Feb 21 2016 15:26:16 with OCaml 4.02.3\ncoqtop version 8.5 (February 2016) *)\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := case proof_admitted.\nRequire Coq.Lists.List.\nImport Coq.Lists.List.\nImport Coq.Classes.Morphisms.\nDefinition list_caset A (P : list A -> Type) (N : P nil) (C : forall x xs, P (x::xs))\nls\n: P ls\n:= match ls with\n| nil => N\n| x::xs => C x xs\nend."
337525310,3692,2014-10-02 22:36:30,"( File reduced by coq-bug-finder from original input, then from 2964 lines to 54 lines, then from 528 lines to 58 lines, then from 43 lines to 29 lines )\n( coqc version trunk (October 2014) compiled on Oct 1 2014 18:13:54 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (6884680) *)\nReserved Notation ""x -> y"" (at level 99, right associativity, y at level 200).\nReserved Notation ""x = y"" (at level 70, no associativity).\nReserved Notation ""x * y"" (at level 40, left associativity).\nDelimit Scope core_scope with core.\nOpen Scope core_scope.\nNotation ""A -> B"" := (forall (_ : A), B) : type_scope.\nGlobal Set Primitive Projections.\nGlobal Set Implicit Arguments.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nNotation ""x * y"" := (prod x y) : type_scope.\nNotation ""( x , y , .. , z )"" := (pair .. (pair x y) .. z) : core_scope.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope."
337519346,3321,2014-05-14 17:54:59,"(* File reduced by coq-bug-finder from original input, then from 5302 lines to 4649 lines, then from 4660 lines to 355 lines, then from 360 lines to 269 lines, then from 269 lines to 175 lines, then from 144 lines to 119 lines, then from 103 lines to 83 lines, then from 86 lines to 36 lines, then from 37 lines to 17 lines *)\nAxiom admit : forall {T}, T.\nDefinition Sect {A B : Type} (s : A -> B) (r : B -> A) := forall x : A, r (s x) = x.\nClass IsEquiv {A B : Type} (f : A -> B) := BuildIsEquiv { equiv_inv : B -> A ; eisretr : Sect equiv_inv f }.\nRecord Equiv A B := BuildEquiv { equiv_fun :> A -> B ; equiv_isequiv :> IsEquiv equiv_fun }.\nDefinition hfiber {A B : Type} (f : A -> B) (y : B) := { x : A & f x = y }.\nDefinition equiv_path (A B : Type) (p : A = B) : Equiv A B := admit.\nClass Univalence := { isequiv_equiv_path :> forall (A B : Type), IsEquiv (equiv_path A B) }.\nDefinition path_universe {Univalence} {A B : Type} (f : A -> B) {feq : IsEquiv f} : (A = B) := admit. Context {ua:Univalence}.\nVariable A:Type.\nGoal forall (I : Type) (f : I -> A),\n{p : I = {a : A & @ hfiber I A f a} & True }.\nintros.\nclear.\nexists (path_universe admit). (* Toplevel input, characters 15-44:"
337527997,3848,2014-12-10 18:31:07,"(* File reduced by coq-bug-finder from original input, then from 3744 lines to 78 lines, then from 80 lines to 28 lines )\n( coqc version trunk (December 2014) compiled on Dec 10 2014 12:26:15 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (c938cb8) *)\nAxiom transport : forall {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x), P y.\nNotation ""p # x"" := (transport _ p x) (right associativity, at level 65, only parsing).\nDefinition Sect {A B : Type} (s : A -> B) (r : B -> A) := forall x : A, r (s x) = x.\nClass IsEquiv {A B} (f : A -> B) := { equiv_inv : B -> A ; eisretr : Sect equiv_inv f }.\nArguments eisretr {A B} f {_} _.\nNotation ""f ^-1"" := (@ equiv_inv _ _ f _) (at level 3, format ""f '^-1'"").\nGeneralizable Variables A B f g e n.\nDefinition functor_forall {P : A -> Type} {Q : B -> Type}\n(f0 : B -> A) (f1 : forall b:B, P (f0 b) -> Q b)\n: (forall a:A, P a) -> (forall b:B, Q b).\nadmit.\nDefined."
337530119,3974,2015-02-01 06:25:09,"(* File reduced by coq-bug-finder from original input, then from 178 lines to 132 lines, then from 148 lines to 73 lines, then from 80 lines to 11 lines )\n( coqc version trunk (January 2015) compiled on Jan 17 2015 21:58:5 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (9e6b28c) *)\nModule Type TypeM.\nEnd TypeM.\nModule Type FunctionM0 (XM : TypeM).\nEnd FunctionM0.\nModule Type FunctionM (XM : TypeM).\nModule ComposeM (XM : TypeM). (* Anomaly: XM already exists. Please report. *)"
337525041,3675,2014-09-29 16:21:37,"(* File reduced by coq-bug-finder from original input, then from 6469 lines to 5311 lines, then from 4723 lines to 3890 lines, then from 3904 lines to 103 lines, then from 108 lines to 48 lines )\n( coqc version trunk (September 2014) compiled on Sep 29 2014 11:31:34 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (f78bc2c) )\nSet Primitive Projections.\nDefinition compose {A B C : Type} (g : B -> C) (f : A -> B) := fun x => g (f x).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition concat {A : Type} {x y z : A} (p : x = y) (q : y = z) : x = z := match p, q with idpath, idpath => idpath end.\nNotation ""p @  q"" := (concat p q) (at level 20) : path_scope.\nAxiom ap : forall {A B:Type} (f:A -> B) {x y:A} (p:x = y), f x = f y.\nDefinition Sect {A B : Type} (s : A -> B) (r : B -> A) := forall x : A, r (s x) = x.\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A ; eisretr : forall x, f (equiv_inv x) = x }.\nNotation ""f ^-1"" := (@ equiv_inv _ _ f _) (at level 3, format ""f '^-1'"") : equiv_scope.\nLocal Open Scope path_scope.\nLocal Open Scope equiv_scope."
337524826,3660,2014-09-25 07:37:14,"(* File reduced by coq-bug-finder from original input, then from 9554 lines to 295 lines, then from 304 lines to 235 lines, then from 206 lines to 79 lines, then from 67 lines to 55 lines )\n( coqc version trunk (September 2014) compiled on Sep 25 2014 2:53:46 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (bec7e09) )\nGeneralizable All Variables.\nDefinition compose {A B C : Type} (g : B -> C) (f : A -> B) := fun x => g (f x).\nNotation ""g 'o' f"" := (compose g f) (at level 40, left associativity) : function_scope.\nOpen Scope function_scope.\nAxiom ap : forall {A B:Type} (f:A -> B) {x y:A} (p:x = y), f x = f y.\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A }.\nRecord Equiv A B := { equiv_fun :> A -> B ; equiv_isequiv :> IsEquiv equiv_fun }.\nNotation ""A <> B"" := (Equiv A B) (at level 85) : equiv_scope.\nAxiom IsHSet : Type -> Type.\nInstance isequiv_compose {IsEquiv A B f} {IsEquiv B C g} : IsEquiv (compose g f) | 1000.\nadmit.\nDefined."
337524510,3640,2014-09-18 04:58:50,"(* File reduced by coq-bug-finder from original input, then from 14990 lines to 70 lines, then from 44 lines to 29 lines )\n( coqc version trunk (September 2014) compiled on Sep 17 2014 0:22:30 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (d34e1ee) )\nSet Primitive Projections.\nSet Implicit Arguments.\nRecord sigT {A} P := existT { pr1 : A ; pr2 : P pr1 }.\nNotation ""{ x : A & P }"" := (sigT (A := A) (fun x : A => P)) : type_scope.\nNotation ""x .1"" := (pr1 x) (at level 3, format ""x '.1'"").\nNotation ""x .2"" := (pr2 x) (at level 3, format ""x '.2'"").\nRecord Equiv A B := { equiv_fun :> A -> B }.\nNotation ""A <> B"" := (Equiv A B) (at level 85).\nInductive Bool : Type := true | false.\nDefinition negb (b : Bool) := if b then false else true.\nAxiom eval_bool_isequiv : forall (f : Bool -> Bool), f false = negb (f true).\nLemma bool_map_equiv_not_idmap (f : { f : Bool <> Bool & ~(forall x, f x = x) })"
337523695,3589,2014-09-06 22:29:31,"(* File reduced by coq-bug-finder from original input, then from 5553 lines to 1522 lines, then from 1285 lines to 173 lines, then from 118 lines to 71 lines, then from 50 lines to 25 lines )\n( coqc version trunk (September 2014) compiled on Sep 6 2014 6:15:6 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (3ea6d68) *)\nGlobal Set Primitive Projections.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\nArguments idpath {A a} , [A] a.\nNotation ""x = y :> A"" := (@ paths A x y) : type_scope.\nNotation ""x = y"" := (x = y :>_) : type_scope.\nDelimit Scope path_scope with path.\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x := match p with idpath => idpath end.\nNotation ""p ^"" := (inverse p) (at level 3, format ""p '^'"") : path_scope.\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y := match p with idpath => u end.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with idpath => idpath end.\nLemma transport_compose {A B} {x y : A} (P : B -> Type) (f : A -> B)\n(p : x = y) (z : P (f x))"
337523283,3566,2014-09-02 02:43:12,"(* File reduced by coq-bug-finder from original input, then from 5098 lines to 133 lines, then from 142 lines to 113 lines, then from 76 lines to 25 lines )\n( coqc version trunk (August 2014) compiled on Aug 31 2014 10:12:32 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (437b91a) *)\nNotation idmap := (fun x => x).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\nArguments idpath {A a} , [A] a.\nNotation ""x = y :> A"" := (@ paths A x y) : type_scope.\nNotation ""x = y"" := (x = y :>_) : type_scope.\nDelimit Scope path_scope with path.\nDefinition concat {A : Type} {x y z : A} (p : x = y) (q : y = z) : x = z := match p, q with idpath, idpath => idpath end.\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x := match p with idpath => idpath end.\nNotation ""p @  q"" := (concat p q) (at level 20) : path_scope.\nNotation ""p ^"" := (inverse p) (at level 3, format ""p '^'"") : path_scope.\nClass IsEquiv {A B : Type} (f : A -> B) := {}.\nAxiom path_universe : forall {A B : Type} (f : A -> B) {feq : IsEquiv f}, (A = B)."
337523147,3560,2014-08-31 22:26:14,"(* File reduced by coq-bug-finder from original input, then from 6236 lines to 1049 lines, then from 920 lines to 209 lines, then from 179 lines to 30 lines )\n( coqc version trunk (August 2014) compiled on Aug 31 2014 10:12:32 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (437b91a) )\nSet Primitive Projections.\nSet Implicit Arguments.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nNotation ""x * y"" := (prod x y) : type_scope.\nRecord Equiv A B := { equiv_fun :> A -> B ; equiv_isequiv : forall P, P equiv_fun }.\nGoal forall (A B : Type) (C : Type), Equiv (A -> B -> C) (A * B -> C).\nProof.\nintros.\nexists (fun u => fun x => u (fst x) (snd x)). ( Toplevel input, characters 15-60:\nError:\nIn environment\nA : Type"
337542928,4769,2016-06-02 18:29:26,"( File reduced by coq-bug-finder from original input, then from 156 lines to 41 lines, then from 237 lines to 45 lines, then from 163 lines to 66 lines, then from 342 lines to 121 lines, then from 353 lines to 184 lines, then from 343 lines to 255 lines, then from 435 lines to 322 lines, then from 475 lines to 351 lines, then from 442 lines to 377 lines, then from 505 lines to 410 lines, then from 591 lines to 481 lines, then from 596 lines to 535 lines, then from 647 lines to 570 lines, then from 669 lines to 596 lines, then from 687 lines to 620 lines, then from 728 lines to 652 lines, then from 1384 lines to 683 lines, then from 984 lines to 707 lines, then from 1124 lines to 734 lines, then from 775 lines to 738 lines, then from 950 lines to 763 lines, then from 857 lines to 798 lines, then from 983 lines to 752 lines, then from 1598 lines to 859 lines, then from 873 lines to 859 lines, then from 875 lines to 862 lines, then from 901 lines to 863 lines, then from 1047 lines to 865 lines, then from 929 lines to 871 lines, then from 989 lines to 884 lines, then from 900 lines to 884 lines, then from 884 lines to 751 lines, then from 763 lines to 593 lines, then from 482 lines to 232 lines, then from 416 lines to 227 lines, then from 290 lines to 231 lines, then from 348 lines to 235 lines, then from 249 lines to 235 lines, then from 249 lines to 172 lines, then from 186 lines to 172 lines, then from 140 lines to 113 lines, then from 127 lines to 113 lines )\n( coqc version trunk (June 2016) compiled on Jun 2 2016 10:16:20 with OCaml 4.02.3\ncoqtop version trunk (June 2016) *)\nReserved Notation ""x -> y"" (at level 99, right associativity, y at level 200).\nReserved Notation ""x * y"" (at level 40, left associativity).\nDelimit Scope type_scope with type.\nOpen Scope type_scope.\nGlobal Set Universe Polymorphism.\nNotation ""A -> B"" := (forall (_ : A), B) : type_scope.\nSet Implicit Arguments.\nGlobal Set Nonrecursive Elimination Schemes.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nNotation ""x * y"" := (prod x y) : type_scope.\nAxiom admit : forall {T}, T.\nDelimit Scope function_scope with function."
337528594,3881,2014-12-24 10:13:46,"(* File reduced by coq-bug-finder from original input, then from 2236 lines to 1877 lines, then from 1652 lines to 160 lines, then from 102 lines to 34 lines )\n( coqc version trunk (December 2014) compiled on Dec 23 2014 22:6:43 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (90ed663) )\nGeneralizable All Variables.\nAxiom admit : forall {T}, T.\nNotation ""g 'o' f"" := (fun x => g (f x)) (at level 40, left associativity).\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with eq_refl => eq_refl end.\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A ; eisretr : forall x, f (equiv_inv x) = x }.\nArguments eisretr {A B} f {_} _.\nNotation ""f ^-1"" := (@ equiv_inv _ _ f _) (at level 3, format ""f '^-1'"").\nGlobal Instance isequiv_compose {IsEquiv A B f} {IsEquiv B C g} : IsEquiv (g o f) | 1000 := admit.\nDefinition isequiv_homotopic {A B} (f : A -> B) (g : A -> B) {IsEquiv A B f} (h : forall x, f x = g x) : IsEquiv g := admit. Global Instance isequiv_inverse {A B} (f : A -> B) {feq : IsEquiv f} : IsEquiv f^-1 | 10000 := admit. Definition cancelR_isequiv {A B C} (f : A -> B) {g : B -> C} {IsEquiv A B f} `{IsEquiv A C (g o f)} : IsEquiv g.\nProof.\npose (fun H => @ isequiv_homotopic _ _ ((g o f) o f^-1) _ H\n(fun b => ap g (eisretr f b))) as k."
337528595,3881,2014-12-29 10:35:48,"( File reduced by coq-bug-finder from original input, then from 2236 lines to 1877 lines, then from 1652 lines to 160 lines, then from 102 lines to 34 lines )\n( coqc version trunk (December 2014) compiled on Dec 23 2014 22:6:43 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (90ed663) *)\nGeneralizable All Variables.\nRequire Import Coq.Init.Notations.\nReserved Notation ""x -> y"" (at level 99, right associativity, y at level 200).\nNotation ""A -> B"" := (forall (_ : A), B) : type_scope.\nAxiom admit : forall {T}, T.\nNotation ""g 'o' f"" := (fun x => g (f x)) (at level 40, left associativity).\nInductive eq {A} (x:A) : A -> Prop := eq_refl : x = x where ""x = y"" := (@ eq _ x y) : type_scope.\nArguments eq_refl {_ }.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with eq_refl => eq_refl end.\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A ; eisretr : forall x, f (equiv_inv x) = x }.\nArguments eisretr {A B} f {} _.\nNotation ""f ^-1"" := (@ equiv_inv _ _ f _) (at level 3, format ""f '^-1'"")."
337550895,5324,2017-01-22 06:33:27,"( File reduced by coq-bug-finder from original input, then from 440 lines to\n147 lines, then from 452 lines to 178 lines, then from 204 lines to 76 lines,\nthen from 102 lines to 44 lines, then from 482 lines to 129 lines, then from\n223 lines to 132 lines, then from 237 lines to 134 lines, then from 183 lines\nto 135 lines, then from 149 lines to 135 lines, then from 112 lines to 46\nlines, then from 60 lines to 47 lines, then from 54 lines to 24 lines, then\nfrom 38 lines to 25 lines )\n( coqc version 8.6rc1 (December 2016) compiled on Dec 8 2016 13:43:59 with\nOCaml 4.02.3\ncoqtop version 8.6rc1 (December 2016) *)\nInductive flat_type := Unit | Prod (A B : flat_type).\nInductive exprf (op : flat_type -> flat_type -> Type) {var : Type} : flat_type\n-> Type :=\n| Op {t1 tR} (opc : op t1 tR) (args : exprf op t1) : exprf op tR.\nInductive op : flat_type -> flat_type -> Type := a : op Unit Unit."
337552553,5434,2017-06-15 17:40:22,"(* File reduced by coq-bug-finder from original input, then from 402 lines to\n11 lines, then from 319 lines to 12 lines, then from 62 lines to 14 lines, then\nfrom 30 lines to 14 lines )\n( coqc version 8.6 (June 2017) compiled on Jun 15 2017 12:8:43 with OCaml\n4.02.3\ncoqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.6,(HEAD\ndetached from 7e992fa) (ce1e1db) *)\nGlobal Set Asymmetric Patterns.\nDefinition proj2_sig_map {A} {P Q : A -> Prop} (f : forall a, P a -> Q a) (x :\n@ sig A P) : @ sig A Q\n:= let 'exist a p := x in exist Q a (f a p).\nGoal forall (feBW' : Type) (g : Prop -> Prop) (f' : feBW' -> Prop), {a0 : feBW'\n| g True = g (f' a0)}.\nclear; intros.\napply (fun f => proj2_sig_map (fun _ p => f_equal f p))."
337526211,3743,2014-10-15 06:10:10,"(* File reduced by coq-bug-finder from original input, then from 967 lines to 469 lines, then from 459 lines to 35 lines )\n( coqc version trunk (October 2014) compiled on Oct 11 2014 1:13:41 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (d65496f) )\nRequire Export Coq.Setoids.Setoid.\nAdd Parametric Relation A\n: A (@ eq A)\ntransitivity proved by transitivity\nas refine_rel.\n( Toplevel input, characters 20-118:\nAnomaly: index to an anonymous variable. Please report. *)"
337522886,3542,2014-08-26 00:33:02,"(* File reduced by coq-bug-finder from original input, then from 1995 lines to 65 lines )\n( coqc version trunk (August 2014) compiled on Aug 25 2014 19:32:34 with OCaml 4.01.0\ncoqtop version trunk (August 2014) )\nSection foo.\nContext {A:Type} {B : A -> Type}.\nContext (f : forall x, B x).\nGoal True.\npose (r := fun k => existT (fun g => forall x, f x = g x)\n(fun x => projT1 (k x)) (fun x => projT2 (k x))).\n( Toplevel input, characters 123-135:\nError:\nIn environment\nA : Type\nB : A -> Type\nf : forall x : A, B x"
337521599,3464,2014-07-28 22:43:59,"(* File reduced by coq-bug-finder from original input, then from 2078 lines to 131 lines, then from 142 lines to 140 lines, then from 95 lines to 29 lines *)\nStructure foo := { bar : Type; baz : bar }.\nCanonical Structure foon := {| bar := nat ; baz := 0 |}.\nDefinition qux := nat.\nDefinition z : qux := 0.\nCheck (eq_refl : baz _ = z).\nSection x.\nCanonical Structure local_foo (b : Type) (p : b) (bad : False) := {| bar := b ; baz := p |}.\nEnd x.\nGoal True.\npose z as z'.\nunfold qux, z in .\nFail Fail pose (eq_refl : baz _ = z').\npose (eq_refl : baz _ = z'). ( Anomaly: Signature and its instance do not match. Please report. *)\nIf I remove the [Fail Fail pose ...], the anomaly on the following [pose] goes away.  I also managed to get ""Error: Conversion test raised an anomaly"" on the following with ssreflect 1.4:"
337521062,3432,2014-07-16 22:37:40,"(* File reduced by coq-bug-finder from original input, then from 3149 lines to 120 lines, then from 129 lines to 86 lines )\nSet Primitive Projections.\nSet Implicit Arguments.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nNotation ""x * y"" := (prod x y) : type_scope.\nNotation ""( x , y , .. , z )"" := (pair .. (pair x y) .. z) : core_scope.\nReserved Infix ""o"" (at level 40, left associativity).\nNotation ""g 'o' f"" := (fun x => g (f x)).\nDelimit Scope category_scope with category.\nDelimit Scope object_scope with object.\nRecord PreCategory :=\n{ object :> Type;\nmorphism : object -> object -> Type;\ncompose' : forall s d d', morphism d d' -> morphism s d -> morphism s d' }.\nArguments morphism !C%category s d : rename."
337521049,3431,2014-07-16 22:36:32,"(* File reduced by coq-bug-finder from original input, then from 3149 lines to 120 lines, then from 129 lines to 86 lines )\nSet Primitive Projections.\nSet Implicit Arguments.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nNotation ""x * y"" := (prod x y) : type_scope.\nNotation ""( x , y , .. , z )"" := (pair .. (pair x y) .. z) : core_scope.\nReserved Infix ""o"" (at level 40, left associativity).\nDefinition compose {A B C : Type} (g : B -> C) (f : A -> B) := fun x => g (f x).\nNotation ""g 'o' f"" := (compose g f).\nDelimit Scope category_scope with category.\nDelimit Scope object_scope with object.\nRecord PreCategory :=\n{ object :> Type;\nmorphism : object -> object -> Type;\ncompose' : forall s d d', morphism d d' -> morphism s d -> morphism s d' }."
337520986,3428,2014-07-16 21:37:41,"(* File reduced by coq-bug-finder from original input, then from 2809 lines to 39 lines )\nSet Primitive Projections.\nModule Export foo.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nEnd foo.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with idpath => idpath end.\nAxiom path_prod : forall {A B : Type} (z z' : prod A B), (fst z = fst z') -> (snd z = snd z') -> (z = z').\nNotation fst := (@ fst _ _).\nNotation snd := (@ snd _ _).\nSet Printing All.\nDefinition ap_fst_path_prod {A B : Type} {z z' : prod A B} (p : @ paths A (fst z) (fst z')) (q : snd z = snd z')\n: ap fst (path_prod z z' p q) = p.\n( Toplevel input, characters 137-138:"
337519361,3322,2014-05-14 23:18:14,"(* File reduced by coq-bug-finder from original input, then from 11971 lines to 11753 lines, then from 7702 lines to 564 lines, then from 571 lines to 61 lines *)\nSet Asymmetric Patterns.\nAxiom admit : forall {T}, T.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y := match p with idpath => u end.\nDefinition path_sigma_uncurried {A : Type} (P : A -> Type) (u v : sigT P)\n(pq : {p : (projT1 u) = (projT1 v) &  transport _ p (projT2 u) = (projT2 v)})\n: u = v.\nProof.\ndestruct pq as [p q], u as [x y], v as [x' y']; simpl in *.\ndestruct p, q; simpl; reflexivity.\nDefined.\nArguments path_sigma_uncurried : simpl never.\nSection opposite.\nLet opposite_functor_involutive_helper"
337517964,3244,2014-02-28 00:27:55,"(* File reduced by coq-bug-finder from 925 lines to 118 lines, then from 100 lines to 76 lines. *)\nRequire Export Setoid RelationClasses Morphisms.\nGlobal Set Implicit Arguments.\nClass Context := { }.\nInductive Comp `{ctx : Context} : Type -> Type :=\n| Bind : forall A B, Comp A -> (A -> Comp B) -> Comp B\n| Pick : forall A, (A -> Prop) -> Comp A.\nAxiom refine : forall {A} {oldCtx newCtx : Context}\n(old : @ Comp oldCtx A)\n(new : @ Comp newCtx A), Prop.\nDefinition refineEquiv {A}\n{oldCtx newCtx : Context}\n(old : @ Comp oldCtx A)\n(new : @ Comp newCtx A) : Prop\n:= refine old new /\ refine new old."
337519381,3324,2014-05-14 23:41:23,"(* File reduced by coq-bug-finder from original input, then from 6462 lines to 5760 lines, then from 5761 lines to 181 lines, then from 191 lines to 181 lines, then from 181 lines to 83 lines, then from 87 lines to 27 lines )\nAxiom admit : forall {T}, T.\nClass IsHProp (A : Type) : Type := {}.\nClass IsHSet (A : Type) : Type := {}.\nInductive Unit : Set := tt.\nRecord hProp := hp { hproptype :> Type ; isp : IsHProp hproptype}.\nDefinition Unit_hp:hProp:=(hp Unit admit).\nRecord hSet := BuildhSet {setT:> Type; iss :> IsHSet setT}.\nCanonical Structure default_HSet:= fun T P => (@ BuildhSet T P).\nGlobal Instance isset_hProp : IsHSet hProp | 0.\nDefinition isepi {X Y} `(f:X->Y) := forall Z: hSet,\nforall g h: Y -> Z, (fun x => g (f x)) = (fun x => h (f x)) -> g = h.\nLemma isepi_issurj {X Y} (f:X->Y): isepi f -> True.\nProof.\nintros epif."
337524627,3649,2014-09-19 09:09:36,"(* File reduced by coq-bug-finder from original input, then from 9518 lines to 404 lines, then from 410 lines to 208 lines, then from 162 lines to 77 lines )\n( coqc version trunk (September 2014) compiled on Sep 18 2014 21:0:5 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (07e4438) *)\nReserved Infix ""o"" (at level 40, left associativity).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nGlobal Set Primitive Projections.\nDelimit Scope morphism_scope with morphism.\nRecord PreCategory :=\n{ object :> Type;\nmorphism : object -> object -> Type;\nidentity : forall x, morphism x x;\ncompose : forall s d d',\n            morphism d d'\n            -> morphism s d\n            -> morphism s d'"
337524641,3649,2015-02-13 18:41:16,"( File reduced by coq-bug-finder from original input, then from 9518 lines to 404 lines, then from 410 lines to 208 lines, then from 162 lines to 77 lines )\n( coqc version trunk (September 2014) compiled on Sep 18 2014 21:0:5 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (07e4438) *)\nReserved Notation ""x -> y"" (at level 99, right associativity, y at level 200).\nReserved Notation ""x = y"" (at level 70, no associativity).\nOpen Scope type_scope.\nAxiom admit : forall {T}, T.\nNotation ""A -> B"" := (forall (_ : A), B) : type_scope.\nReserved Infix ""o"" (at level 40, left associativity).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nLtac constr_eq a b := let test := constr:(@ idpath _ _ : a = b) in idtac.\nGlobal Set Primitive Projections.\nDelimit Scope morphism_scope with morphism.\nRecord PreCategory :=\n{ object :> Type;"
337524526,3641,2014-09-18 09:03:41,"(* File reduced by coq-bug-finder from original input, then from 7593 lines to 243 lines, then from 256 lines to 102 lines, then from\n104 lines to 28 lines )\n( coqc version trunk (September 2014) compiled on Sep 17 2014 0:22:30 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (d34e1ee) )\nSet Primitive Projections.\nSet Implicit Arguments.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nNotation ""x * y"" := (prod x y) : type_scope.\nNotation ""( x , y , .. , z )"" := (pair .. (pair x y) .. z) : core_scope.\nClass UnitSubuniverse := { O : Type -> Type ; O_unit : forall T, T -> O T }.\nClass ReflectiveSubuniverse := { rsubu_usubu : UnitSubuniverse ; O_rectnd : forall {P Q : Type} (f : P -> Q), O P -> Q }.\nGlobal Existing Instance rsubu_usubu.\nContext {subU : ReflectiveSubuniverse}.\nGoal forall (A B : Type) (x : O A * O B) (x0 : B),\n{ g : _ & O_rectnd (fun z : A * B => (O_unit (fst z), O_unit (snd z)))"
337532191,4096,2015-03-01 23:02:04,"(* File reduced by coq-bug-finder from original input, then from 861 lines to 106 lines )\n( coqc version 8.5beta1 (March 2015) compiled on Mar 1 2015 6:38:49 with OCaml 4.01.0\ncoqtop version 8.5beta1 (March 2015) *)\nDefinition relation (A : Type) := A -> A -> Type.\nClass Transitive {A} (R : relation A) :=\ntransitivity : forall x y z, R x y -> R y z -> R x z.\nTactic Notation ""etransitivity"" open_constr(y) :=\nlet R := match goal with |- ?R ?x ?z => constr:(R) end in\nlet x := match goal with |- ?R ?x ?z => constr:(x) end in\nlet z := match goal with |- ?R ?x ?z => constr:(z) end in\nlet pre_proof_term_head := constr:(@ transitivity _ R _) in\nlet proof_term_head := (eval cbn in pre_proof_term_head) in\nrefine (proof_term_head x y z _ _); [ change (R x y) | change (R y z) ].\nLtac transitivity x := etransitivity x.\nNotation idmap := (fun x => x)."
337532194,4096,2015-03-02 00:29:23,"( File reduced by coq-bug-finder from original input, then from 861 lines to 106 lines, then from 122 lines to 53 lines, then from 7\n0 lines to 40 lines )\n( coqc version 8.5beta1 (February 2015) compiled on Feb 27 2015 15:10:37 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (fc1b3ef) )\nSet Universe Polymorphism.\nNotation relation A := (A -> A -> Type) (only parsing).\nClass Transitive {A} (R : relation A) := transitivity : forall x y z, R x y -> R y z -> R x z.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nRecord Equiv A B := { equiv_fun : A -> B }.\nLemma bippathEQbipequiv (X : Type)\n: Equiv (X = X) (X -> X).\nProof.\nassert (Equiv (X = X) (X = X)).\nrefine (@ transitivity _ Equiv _ (X = X) (X = X) (X = X) _ _) || fail ""too early"".\nUndo 2."
337554744,5578,2017-06-03 18:01:44,"( File reduced by coq-bug-finder from original input, then from 1549 lines to\n298 lines, then from 277 lines to 133 lines, then from 985 lines to 138 lines,\nthen from 206 lines to 139 lines, then from 203 lines to 142 lines, then from\n262 lines to 152 lines, then from 567 lines to 151 lines, then from 3746 lines\nto 151 lines, then from 577 lines to 151 lines, then from 187 lines to 151\nlines, thenfrom 981 lines to 940 lines, then from 938 lines to 175 lines, then\nfrom 589 lines to 205 lines, then from 3797 lines to 205 lines, then from 628\nlines to 206 lines, then from 238 lines to 205 lines, then from 1346 lines to\n213 lines, then from 633 lines to 214 lines, then from 243 lines to 213 lines,\nthen from 5656 lines to 245 lines, then from 661 lines to 272 lines, then from\n3856 lines to 352 lines, then from 1266 lines to 407 lines, then from 421 lines\nto 406 lines, then from 424 lines to 91 lines, then from 105 lines to 91 lines,\nthen from 85 lines to 55 lines, then from 69 lines to 55 lines )\n( coqc version trunk (May 2017) compiled on May 30 2017 13:28:59 with OCaml\n4.02.3"
337525573,3709,2014-10-09 01:59:17,"(* File reduced by coq-bug-finder from original input, then from 10759 lines to 120 lines, then from 119 lines to 38 lines )\n( coqc version trunk (October 2014) compiled on Oct 8 2014 13:38:17 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (335cf28) )\nDefinition relation (A : Type) := A -> A -> Type.\nAxiom concat : forall {A : Type} {x y z : A} (p : x = y) (q : y = z), x = z.\nAxiom transport : forall {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x), P y.\nAxiom transport_const : forall {A B : Type} {x1 x2 : A} (p : x1 = x2) (y : B), transport (fun x => B) p y = y.\nInductive quotient {A} (R : relation A) : Type := class_of : A -> quotient R.\nAxiom related_classes_eq : forall {A R} {x y : A}, R x y -> class_of R x = class_of R y.\nModule NonPrim.\nUnset Keyed Unification.\nUnset Primitive Projections.\nRecord hProp := hp { hproptype :> Type }.\nGoal forall (A : Type) (R : relation A)\n(x y : A) (H0 : R x y),"
337525575,3709,2014-10-28 20:55:24,"(* File reduced by coq-bug-finder from original input, then from 10759 lines to 120 lines, then from 119 lines to 38 lines )\n( coqc version trunk (October 2014) compiled on Oct 28 2014 14:33:38 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (53bfe9c) )\nModule NonPrim.\nUnset Primitive Projections.\nRecord hProp := hp { hproptype :> Type }.\nGoal forall (h : (Type -> hProp) -> (Type -> hProp)) k f,\n(forall y, h y = y) ->\nh (fun b : Type => {| hproptype := f b |}) = k.\nProof.\nintros h k f H.\netransitivity.\napply H.\nadmit.\nDefined."
337529168,3914,2015-01-12 17:38:15,"(* File reduced by coq-bug-finder from original input, then from 1638 lines to 36 lines, then from 35 lines to 20 lines )\n( coqc version trunk (January 2015) compiled on Jan 12 2015 10:58:30 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (13a55aa) *)\nNotation idmap := (fun x => x).\nNotation compose := (fun g f x => g (f x)).\nNotation ""g 'o' f"" := (compose g f) (at level 40, left associativity) : function_scope.\nOpen Scope function_scope.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition pointwise_paths {A} {P:A->Type} (f g:forall x:A, P x) := forall x:A, f x = g x.\nNotation ""f == g"" := (pointwise_paths f g) (at level 70, no associativity) : type_scope.\nClass IsPreIdempotent {X : Type} (f : X -> X) := isidem : forall x, f (f x) = f x.\nGlobal Instance ispreidem_idmap (X : Type) : @ IsPreIdempotent X idmap := fun _ => idpath.\nGoal forall X A (r : X -> A) (s : A -> X) (H : s o r == idmap -> forall x : X, x = x), Type.\nintros."
337528898,3895,2014-12-31 12:32:59,"(* File reduced by coq-bug-finder from original input, then from 6046 lines to 37 lines, then from 34 lines to 19 lines )\n( coqc version trunk (December 2014) compiled on Dec 23 2014 22:6:43 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (90ed663) *)\nNotation pr1 := (@ projT1 _ _).\nNotation compose := (fun g' f' x => g' (f' x)).\nNotation ""g 'o' f"" := (compose g f) (at level 40, left associativity) : function_scope.\nOpen Scope function_scope.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with eq_refl => eq_refl end.\nDefinition pointwise_paths {A} {P:A->Type} (f g:forall x:A, P x) := forall x:A, f x = g x.\nNotation ""f == g"" := (pointwise_paths f g) (at level 70, no associativity) : type_scope.\nTheorem Univalence_implies_FunextNondep (A B : Type)\n: forall f g : A -> B, f == g -> f = g.\nProof.\nintros f g p.\npose (d := fun x : A => existT (fun xy => fst xy = snd xy) (f x, f x) (eq_refl (f x)))."
337526925,3782,2014-10-28 21:51:43,"(* File reduced by coq-bug-finder from original input, then from 2674 lines to 136 lines, then from 115 lines to 61 lines )\n( coqc version trunk (October 2014) compiled on Oct 28 2014 14:33:38 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,(no branch) (53bfe9c) )\nClass IsEquiv {A B : Type} (f : A -> B) := {}.\nRecord Equiv A B := { equiv_fun : A -> B ; equiv_isequiv : IsEquiv equiv_fun }.\nArguments equiv_fun {A B} _ _.\nRecord PreCategory := { object :> Type ; morphism : object -> object -> Type }.\nSet Printing Coercions.\nSet Printing Implicit.\nModule NonPrim.\nUnset Primitive Projections.\nRecord TruncType (n : nat) := { trunctype_type :> Type }.\nCanonical Structure default_TruncType := fun n T => (@ Build_TruncType n T).\nGoal (forall (s d : TruncType 0) (m : trunctype_type 0 s -> trunctype_type 0 d),\n@ IsEquiv (trunctype_type 0 s) (trunctype_type 0 d) m -> Type) ->"
337525586,3710,2014-10-09 08:24:27,"(* File reduced by coq-bug-finder from original input, then from 13477 lines to 1457 lines, then from 1553 lines to 1586 lines, then \nfrom 1574 lines to 823 lines, then from 837 lines to 802 lines, then from 793 lines to 657 lines, then from 661 lines to 233 lines, t\nhen from 142 lines to 65 lines )\n( coqc version trunk (October 2014) compiled on Oct 8 2014 13:38:17 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (335cf28) )\nSet Universe Polymorphism.\nSet Primitive Projections.\nSet Implicit Arguments.\nRecord sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\nNotation ""{ x : A & P }"" := (sigT (fun x:A => P)) : type_scope.\nDefinition relation (A : Type) := A -> A -> Type.\nClass Reflexive {A} (R : relation A) := reflexivity : forall x : A, R x x.\nNotation ""( x ; y )"" := (existT _ x y).\nNotation ""x .1"" := (projT1 x) (at level 3, format ""x '.1'"").\nReserved Infix ""o"" (at level 40, left associativity)."
337524929,3668,2014-09-26 12:55:48,"(* File reduced by coq-bug-finder from original input, then from 6329 lines to 110 lines, then from 115 lines to 88 lines, then from 93 lines to 72 lines )\n( coqc version trunk (September 2014) compiled on Sep 25 2014 2:53:46 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (bec7e09) *)\nNotation ""( x ; y )"" := (existT _ x y).\nNotation ""x .1"" := (projT1 x) (at level 3, format ""x '.1'"").\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A }.\nRecord Equiv A B := { equiv_fun :> A -> B ; equiv_isequiv :> IsEquiv equiv_fun }.\nNotation ""A <> B"" := (Equiv A B) (at level 85).\nAxiom IsHProp : Type -> Type.\nInductive Bool := true | false.\nDefinition negb (b : Bool) := if b then false else true.\nHypothesis LEM : forall A : Type, IsHProp A -> A + (A -> False).\nModule NonPrim.\nClass Contr (A : Type) := { center : A ; contr : (forall y : A, center = y) }.\nDefinition Book_6_9 : forall X, X -> X."
337524903,3666,2014-09-26 12:29:07,"(* File reduced by coq-bug-finder from original input, then from 11542 lines to 325 lines, then from 347 lines to 56 lines, then from 58 lines to 15 lines )\n( coqc version trunk (September 2014) compiled on Sep 25 2014 2:53:46 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (bec7e09) *)\nAxiom transport : forall {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x), P y.\nNotation ""p # x"" := (transport _ p x) (right associativity, at level 65, only parsing).\nInductive V : Type@ {U'} := | set {A : Type@ {U}} (f : A -> V) : V.\nModule NonPrim.\nRecord hProp := hp { hproptype :> Type ; isp : Set}.\nGoal forall (A B : Type) (H_f : A -> V -> hProp) (H_g : B -> V -> hProp)\n(C : Type) (h : C -> V) (b : B) (a : A) (c : C),\nH_f a (h c) -> H_f a (h c) = H_g b (h c) -> H_g b (h c).\nintros A B H_f H_g C h b a c H3 H'.\nexact (@ transport hProp (fun x => x) _ _ H' H3).\nUndo.\nexact (H' # H3)."
337524345,3627,2014-09-16 00:03:43,"(* File reduced by coq-bug-finder from original input, then from 1924 lines to 58 lines, then from 48 lines to 37 lines )\n( coqc version trunk (September 2014) compiled on Sep 15 2014 9:34:0 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (708f063) )\nSet Primitive Projections.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nAxiom concat : forall {A : Type} {x y z : A} (p : x = y) (q : y = z), x = z.\nNotation ""1"" := idpath : path_scope.\nNotation ""p @  q"" := (concat p q) (at level 20) : path_scope.\nAxiom ap : forall {A B:Type} (f:A -> B) {x y:A} (p:x = y), f x = f y.\nDefinition Sect {A B : Type} (s : A -> B) (r : B -> A) := forall x : A, r (s x) = x.\nClass IsEquiv {A B : Type} (f : A -> B) :=\n{ equiv_inv : B -> A ;\neisretr : Sect equiv_inv f;\neissect : Sect f equiv_inv }."
337522828,3539,2014-08-24 20:48:30,"( File reduced by coq-bug-finder from original input, then from 11678 lines to 11330 lines, then from 10721 lines to 9544 lines, then from 9549 lines to 794 lines, then from 810 lines to 785 lines, then from 628 lines to 246 lines, then from 220 lines to 89 lines, then from 80 lines to 47 lines )\n( coqc version trunk (August 2014) compiled on Aug 22 2014 4:17:28 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (a67cc69) *)\nSet Implicit Arguments.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y := match p with idpath => u end.\nLocal Set Primitive Projections.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nNotation ""x * y"" := (prod x y) : type_scope.\nNotation ""( x , y , .. , z )"" := (pair .. (pair x y) .. z) : core_scope.\nAxiom path_prod : forall {A B : Type} (z z' : A * B), (fst z = fst z') -> (snd z = snd z') -> (z = z').\nAxiom transport_path_prod : forall A B (P : A * B -> Type) (x y : A * B) (HA : fst x = fst y) (HB : snd x = snd y) Px,\ntransport P (path_prod _ _ HA HB) Px\n= transport (fun x => P (x, snd y)) HA (transport (fun y => P (fst x, y)) HB Px)."
337521237,3446,2014-07-21 09:53:38,"(* File reduced by coq-bug-finder from original input, then from 7372 lines to 539 lines, then from 531 lines to 107 lines, then from 76 lines to 46 lines )\nSet Asymmetric Patterns.\nSet Universe Polymorphism.\nArguments projT1 {_ _} _.\nNotation ""( x ; y )"" := (existT _ x y).\nNotation pr1 := projT1.\nNotation ""x .1"" := (projT1 x) (at level 3).\nNotation ""x .2"" := (projT2 x) (at level 3).\nDefinition compose {A B C : Type} (g : B -> C) (f : A -> B) := fun x => g (f x).\nNotation ""g 'o' f"" := (compose g f) (at level 40, left associativity).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y := match p with idpath => u end.\nNotation ""p # x"" := (transport _ p x) (right associativity, at level 65, only parsing).\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A }."
337531446,4057,2015-02-17 21:08:28,"(* File reduced by coq-bug-finder from original input, then from 6051 lines to\n233 lines, then from 210 lines to 194 lines )\n( coqc version 8.4pl5 (December 2014) compiled on Dec 28 2014 03:23:16 with\nOCaml 4.01.0\ncoqtop version 8.4pl5 (December 2014) *)\nRequire Coq.Strings.String.\nSet Implicit Arguments.\nReserved Notation ""[ x ]"".\nRecord string_like (CharType : Type) :=\n{\nString :> Type;\nSingleton : CharType -> String where ""[ x ]"" := (Singleton x);\nEmpty : String;\nConcat : String -> String -> String where ""x ++ y"" := (Concat x y);\nbool_eq : String -> String -> bool;"
337522376,3510,2014-08-12 19:32:58,"(* File reduced by coq-bug-finder from original input, then from 5752 lines to 3828 lines, then from 2707 lines to 193 lines, then from 214 lines to 36 lines )\nLemma match_option_fn T (b : option T) A B s n\n: match b as b return forall x : A, B b x with\n| Some k => s k\n| None => n\nend\n= fun x : A => match b as b return B b x with\n| Some k => s k x\n| None => n x\nend.\nadmit.\nDefined.\nLemma match_option_comm_2 T (p : option T) A B R (f : forall (x : A) (y : B x), R x y) (s1 : T -> A) (s2 : forall x : T, B (s1 x)) n1 n2\n: match p as p return R match p with\n| Some k => s1 k"
337522322,3505,2014-08-10 14:39:04,"(* File reduced by coq-bug-finder from original input, then from 7421 lines to 6082 lines, then from 5860 lines to 5369 lines, then from 5300 lines to 165 lines, then from 111 lines to 38 lines )\nSet Implicit Arguments.\nRecord PreCategory :=\n{ object :> Type;\nmorphism : object -> object -> Type;\nidentity : forall x, morphism x x }.\nBind Scope category_scope with PreCategory.\nLocal Notation ""1"" := (identity _ _) : morphism_scope.\nLocal Open Scope morphism_scope.\nDefinition prod (C D : PreCategory) : PreCategory\n:= @ Build_PreCategory\n(C * D)%type\n(fun s d => (morphism C (fst s) (fst d) * morphism D (snd s) (snd d))%type)\n(fun x => (identity _ (fst x), identity _ (snd x))).\nLocal Infix """" := prod : category_scope."
337521970,3484,2014-08-04 07:52:05,"(* File reduced by coq-bug-finder from original input, then from 14259 lines to 305 lines, then from 237 lines to 120 lines, then from 100 lines to 30 lines )\nSet Primitive Projections.\nRecord sigT (A : Type) (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\nNotation ""{ x : A & P }"" := (@ sigT A (fun x : A => P)) : type_scope.\nNotation pr1 := (@ projT1 _ _).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with idpath => idpath end.\nGoal forall (T : Type) (H :  { g : T & g = g }) (x : T), projT1 H = projT1 (existT _ (fun g : T => g = g) x idpath).\nProof.\nintros.\nlet y := match goal with |- projT1 ?x = projT1 ?y => constr:(y) end in\napply (@ ap _ _ pr1 _ y).\nUndo.\nUnset Printing Notations."
337521116,3437,2014-07-17 18:09:00,"(* File reduced by coq-bug-finder from original input, then from 3419 lines to 51 lines, then from 69 lines to 14 lines )\nSet Primitive Projections.\nSet Implicit Arguments.\nGeneralizable All Variables.\nRecord sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\nNotation ""( x ; y )"" := (existT _ x y).\nNotation ""x .1"" := (projT1 x) (at level 3).\nNotation ""x .2"" := (projT2 x) (at level 3).\nNotation ""{ x : A & P }"" := (sigT (fun x:A => P)) : type_scope.\nSet Printing All.\nDefinition f `(Q : { a : A & P a } -> Type) (apq : sigT Q) : {a : A & {p : P a & Q (a;p)}} := (apq.1.1; (apq.1.2; apq.2)).\n( Toplevel input, characters 109-136:\nError:\nIn environment\nA : Type"
337519319,3319,2014-05-14 14:46:48,"(* File reduced by coq-bug-finder from original input, then from 5353 lines to 4545 lines, then from 4513 lines to 4504 lines, then from 4515 lines to 4508 lines, then from 4519 lines to 132 lines, then from 111 lines to 66 lines, then from 68 lines to 35 lines *)\nSet Implicit Arguments.\nInductive paths {A : Type} (a : A) : A -> Type :=\nidpath : paths a a\nwhere ""x = y"" := (@ paths _ x y) : type_scope.\nRecord PreCategory := { obj :> Type; morphism : obj -> obj -> Type }.\nRecord NotionOfStructure (X : PreCategory) :=\n{ structure :> X -> Type;\nis_structure_homomorphism\n: forall x y (f : morphism X x y) (a : structure x) (b : structure y), Type }.\nSection precategory.\nVariable X : PreCategory.\nVariable P : NotionOfStructure X.\nLocal Notation object := { x : X & P x }.\nRecord morphism' (xa yb : object) := {}."
337515003,3068,2013-06-24 13:55:31,"Thanks to coq-bug-finder the code to reproduce is quite short:\n================================================================\nSection Counted_list.\nVariable A : Type.\nInductive counted_list : nat -> Type :=\n| counted_nil : counted_list 0\n| counted_cons : forall(n : nat),\nA -> counted_list n -> counted_list (S n).\nFixpoint counted_def_nth{n : nat}(l : counted_list n)\n(i : nat)(def : A) : A :=\nmatch i with\n| 0 => match l with\n| counted_nil => def\n| counted_cons _ a _ => a\nend"
337546135,5004,2016-08-08 21:15:28,"( File reduced by coq-bug-finder from original input, then from 174 lines to\n83 lines, then from 97 lines to 83 lines )\n( coqc version trunk (July 2016) compiled on Jul 29 2016 16:1:59 with OCaml\n4.02.3\ncoqtop version [..]:[..]/Downloads/coq/coq-v8.6,v8.6\n(dabe6d0) *)\nRequire Coq.ZArith.Zpower.\nImport Coq.ZArith.BinInt.\nFixpoint tuple' T n : Type :=\nmatch n with\n| O => T\n| S n' => (tuple' T n' * T)%type\nend.\nDefinition tuple T n : Type :=\nmatch n with"
337522364,3509,2014-08-12 19:31:58,"(* File reduced by coq-bug-finder from original input, then from 5752 lines to 3828 lines, then from 2707 lines to 193 lines, then from 202 lines to 20 lines )\nLemma match_bool_fn b A B xT xF\n: match b as b return forall x : A, B b x with\n| true => xT\n| false => xF\nend\n= fun x : A => match b as b return B b x with\n| true => xT x\n| false => xF x\nend.\nadmit.\nDefined.\nLemma match_bool_comm_1 (b : bool) A B (F : forall x : A, B x) t f\n: (if b as b return B (if b then t else f) then F t else F f)\n= F (if b then t else f)."
337519761,3347,2014-05-26 13:28:40,"(* File reduced by coq-bug-finder from original input, then from 12653 lines to 12453 lines, then from 11673 lines to 681 lines, then from 693 lines to 469 lines, then from 375 lines to 56 lines )\nSet Universe Polymorphism.\nNotation Type1 := $(let U := constr:(Type) in let gt := constr:(Set : U) in exact U)$ (only parsing).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nInductive Unit : Type1 := tt : Unit.\nFail Check Unit : Set. ( [Check Unit : Set] should fail if [Type1] is defined correctly )\nRecord PreCategory := { object :> Type ; morphism : object -> object -> Type }.\nRecord Functor (C D : PreCategory) := { object_of :> C -> D }.\nDefinition indiscrete_category X : PreCategory := @ Build_PreCategory X (fun _ _ => Unit).\nDefinition from_terminal (C : PreCategory) one (c : C) := Build_Functor one C (fun _ => c).\nLocal Notation ""! x"" := (from_terminal _ (indiscrete_category Unit) x) (at level 3).\nRecord NaturalTransformation {C D} (F G : Functor C D) :=\n{ components_of :> forall c, morphism D (F c) (G c);\ncommutes : forall c, components_of c = components_of c }.\nDefinition slice_category_induced_functor_nt (D : PreCategory) s d (m : morphism D s d)"
337529108,3909,2015-01-11 09:28:32,"(* File reduced by coq-bug-finder from original input, then from 2352 lines to 162 lines, then from 138 lines to 50 lines )\n( coqc version trunk (January 2015) compiled on Jan 10 2015 10:54:47 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (b858f93) *)\nNotation compose g f := (fun x => g (f x)).\nNotation ""g 'o' f"" := (compose g f) (at level 40, left associativity) : function_scope.\nOpen Scope function_scope.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\nArguments idpath {A a} , [A] a.\nNotation ""x = y :> A"" := (@ paths A x y) : type_scope.\nNotation ""x = y"" := (x = y :>_) : type_scope.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with idpath => idpath end.\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A }.\nNotation ""f ^-1"" := (@ equiv_inv _ _ f _) (at level 3, format ""f '^-1'"") : equiv_scope.\nLocal Open Scope equiv_scope.\nGeneralizable Variables A B C f g."
337550864,5321,2017-01-22 01:09:30,"( File reduced by coq-bug-finder from original input, then from 1317 lines to\n51 lines, then from 149 lines to 52 lines, then from 321 lines to 58 lines,\nthen from 72 lines to 59 lines, then from 70 lines to 56 lines, then from 1242\nlines to 59 lines, then from 65 lines to 59 lines, then from 53 lines to 31\nlines, then from 37 lines to 31 lines )\n( coqc version 8.6rc1 (December 2016) compiled on Dec 8 2016 13:43:59 with\nOCaml 4.02.3\ncoqtop version 8.6rc1 (December 2016) *)\nModule Export AdmitTactic.\nModule Import LocalFalse.\nInductive False := .\nEnd LocalFalse.\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := abstract case proof_admitted.\nEnd AdmitTactic."
337520229,3375,2014-06-10 22:54:31,"( File reduced by coq-bug-finder from original input, then from 5968 lines to 11933 lines, then from 11239 lines to 11231 lines, then from 10365 lines to 446 lines, then from 456 lines to 379 lines, then from 391 lines to 373 lines, then from 369 lines to 351 lines, then from 350 lines to 340 lines, then from 348 lines to 320 lines, then from 328 lines to 302 lines, then from 330 lines to 45 lines *)\nSet Universe Polymorphism.\nAxiom admit : forall {T}, T.\nDefinition UU := Set.\nDefinition dirprod ( X Y : UU ) := sigT ( fun x : X => Y ) .\nDefinition dirprodpair { X Y : UU } := existT ( fun x : X => Y ) .\nDefinition hProp := sigT (fun X : Type => admit).\nAxiom hProppair : forall ( X : UU ) ( is : admit ), hProp@ {Set i}.\nDefinition hProptoType := @ projT1 _ _ : hProp -> Type .\nCoercion hProptoType: hProp >-> Sortclass.\nDefinition ishinh_UU ( X : UU ) : UU := forall P: Set, ( ( X -> P ) -> P ).\nDefinition ishinh ( X : UU ) : hProp := hProppair ( ishinh_UU X ) admit.\nDefinition hsubtypes ( X : UU ) : Type := X -> hProp.\nAxiom carrier : forall { X : UU } ( A : hsubtypes X ), Type.\nDefinition hrel ( X : UU ) : Type := X -> X -> hProp."
337519519,3331,2014-05-16 19:55:48,"(* File reduced by coq-bug-finder from original input, then from 6303 lines to 66 lines, then from 63 lines to 36 lines )\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y :> A"" := (@ paths A x y) : type_scope.\nArguments idpath {A a} , [A] a.\nNotation ""x = y"" := (x = y :>) : type_scope.\nClass Contr_internal (A : Type) := BuildContr { center : A ; contr : (forall y : A, center = y) }.\nInductive trunc_index : Type :=\n| minus_two : trunc_index\n| trunc_S : trunc_index -> trunc_index.\nFixpoint IsTrunc_internal (n : trunc_index) (A : Type) : Type :=\nmatch n with\n| minus_two => Contr_internal A\n| trunc_S n' => forall (x y : A), IsTrunc_internal n' (x = y)\nend.\nClass IsTrunc (n : trunc_index) (A : Type) : Type := Trunc_is_trunc : IsTrunc_internal n A.\nInstance istrunc_paths (A : Type) n {H : IsTrunc (trunc_S n) A} (x y : A) : IsTrunc n (x = y) := H x y. Notation Contr := (IsTrunc minus_two). Section groupoid_category. Variable X : Type. Context {H : IsTrunc (trunc_S (trunc_S (trunc_S minus_two))) X}."
337521985,3485,2014-08-04 11:56:35,"(* File reduced by coq-bug-finder from original input, then from 7794 lines to 258 lines, then from 224 lines to 188 lines, then from 181 lines to 158 lines *)\nSet Universe Polymorphism.\nSet Primitive Projections.\nReserved Infix ""o"" (at level 40, left associativity).\nDefinition relation (A : Type) := A -> A -> Type.\nClass Transitive {A} (R : relation A) := transitivity : forall x y z, R x y -> R y z -> R x z.\nTactic Notation ""etransitivity"" open_constr(y) :=\nlet R := match goal with |- ?R ?x ?z => constr:(R) end in\nlet x := match goal with |- ?R ?x ?z => constr:(x) end in\nlet z := match goal with |- ?R ?x ?z => constr:(z) end in\nrefine (@ transitivity _ R _ x y z _ _).\nTactic Notation ""etransitivity"" := etransitivity _.\nNotation ""( x ; y )"" := (existT _ x y) : fibration_scope.\nOpen Scope fibration_scope.\nNotation ""x .1"" := (projT1 x) (at level 3) : fibration_scope."
337543387,4809,2016-06-11 18:35:27,"( File reduced by coq-bug-finder from original input, then from 322 lines to 37 lines, then from 51 lines to 37 lines, then from 51 lines to 36 lines, then from 50 lines to 36 lines, then from 120 lines to 89 lines, then from 103 lines to 89 lines, then from 158 lines to 89 lines, then from 221 lines to 130 lines, then from 198 lines to 130 lines, then from 396 lines to 321 lines, then from 424 lines to 321 lines, then from 698 lines to 321 lines, then from 484 lines to 321 lines, then from 728 lines to 321 lines, then from 499 lines to 321 lines, then from 575 lines to 321 lines, then from 639 lines to 321 lines, then from 632 lines to 321 lines, then from 648 lines to 322 lines, then from 1000 lines to 321 lines, then from 575 lines to 321 lines, then from 464 lines to 321 lines, then from 687 lines to 322 lines, then from 516 lines to 321 lines, then from 680 lines to 322 lines, then from 902 lines to 322 lines, then from 666 lines to 322 lines, then from 476 lines to 321 lines, then from 814 lines to 321 lines, then from 466 lines to 321 lines, then from 1121 lines to 321 lines, then from 600 lines to 321 lines, then from 468 lines to 321 lines, then from 619 lines to 321 lines, then from 811 lines to 351 lines, then from 418 lines to 351 lines, then from 995 lines to 377 lines, then from 411 lines to 198 lines, then from 966 lines to 275 lines, then from 379 lines to 336 lines, then from 590 lines to 397 lines, then from 411 lines to 396 lines, then from 411 lines to 296 lines, then from 310 lines to 296 lines, then from 344 lines to 174 lines, then from 188 lines to 174 lines, then from 167 lines to 122 lines, then from 136 lines to 122 lines )\n( coqc version 8.5pl1 (April 2016) compiled on Apr 18 2016 14:48:5 with OCaml 4.02.3\ncoqtop version 8.5pl1 (April 2016) *)\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := abstract case proof_admitted.\nRequire Coq.nsatz.Nsatz.\nImport Coq.ZArith.BinInt.\nImport Coq.ZArith.Znumtheory.\nDefinition F (modulus : BinInt.Z) : Set.\nexact { z : BinInt.Z | z = z mod modulus }.\nDefined.\nSection FieldOperations.\nContext {m : BinInt.Z}.\nDefinition pow : F m -> BinNums.N -> F m.\nadmit."
337549080,5198,2016-11-12 21:22:31,"( File reduced by coq-bug-finder from original input, then from 286 lines to\n27 lines, then from 224 lines to 53 lines, then from 218 lines to 56 lines,\nthen from 269 lines to 180 lines, then from 132 lines to 48 lines, then from\n253 lines to 65 lines, then from 79 lines to 65 lines )\n( coqc version 8.6.0 (November 2016) compiled on Nov 12 2016 14:43:52 with\nOCaml 4.02.3\ncoqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.6,v8.6\n(7e992fa) *)\nAxiom admit : forall {T}, T.\nSet Printing Implicit.\nInductive nat := O | S (_ : nat).\nAxiom f : forall (_ _ : nat), nat.\nClass ZLikeOps (e : nat)\n:= { LargeT : Type ; SmallT : Type ; CarryAdd : forall (_ _ : LargeT), LargeT\n}."
337525242,3686,2014-09-30 17:29:22,"(* File reduced by coq-bug-finder from original input, then from 14001 lines to 844 lines, then from 848 lines to 615 lines, then fro\nm 624 lines to 301 lines, then from 190 lines to 89 lines )\n( coqc version trunk (September 2014) compiled on Sep 29 2014 14:5:39 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-HoTT,(no branch) (e872655) )\nSet Universe Polymorphism.\nSet Implicit Arguments.\nRecord PreCategory := { object :> Type ; morphism : object -> object -> Type }.\nBind Scope category_scope with PreCategory.\nRecord Functor (C D : PreCategory) :=\n{ object_of :> C -> D;\nmorphism_of : forall s d, morphism C s d -> morphism D (object_of s) (object_of d);\nidentity_of : forall s m, morphism_of s s m = morphism_of s s m }.\nDefinition sub_pre_cat (P : PreCategory -> Type) : PreCategory.\nProof.\nexact (@ Build_PreCategory PreCategory Functor)."
337523247,3565,2014-09-02 02:37:11,"(* File reduced by coq-bug-finder from original input, then from 5104 lines to 163 lines, then from 121 lines to 52 lines )\n( coqc version trunk (August 2014) compiled on Aug 31 2014 10:12:32 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (437b91a) *)\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\nArguments idpath {A a} , [A] a.\nNotation ""x = y :> A"" := (@ paths A x y) : type_scope.\nNotation ""x = y"" := (x = y :>_) : type_scope.\nDelimit Scope path_scope with path.\nDefinition concat {A : Type} {x y z : A} (p : x = y) (q : y = z) : x = z := match p, q with idpath, idpath => idpath end.\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x := match p with idpath => idpath end.\nNotation ""1"" := idpath : path_scope.\nNotation ""p @  q"" := (concat p q) (at level 20) : path_scope.\nNotation ""p ^"" := (inverse p) (at level 3, format ""p '^'"") : path_scope.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with idpath => idpath end.\nDefinition Sect {A B : Type} (s : A -> B) (r : B -> A) := forall x : A, r (s x) = x."
337539364,4527,2016-01-24 07:53:38,"(* File reduced by coq-bug-finder from original input, then from 1199 lines to \n430 lines, then from 444 lines to 430 lines, then from 964 lines to 255 lines, \nthen from 269 lines to 255 lines *)\n(* coqc version 8.5 (January 2016) compiled on Jan 23 2016 16:15:22 with OCaml \n4.01.0\n   coqtop version 8.5 (January 2016) *)\nInductive False := .\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := case proof_admitted.\nRequire Coq.Init.Datatypes.\n\nImport Coq.Init.Notations.\n\nGlobal Set Universe Polymorphism.\n"
337524953,3670,2014-09-27 08:17:44,"(* File reduced by coq-bug-finder from original input, then from 7668 lines to 80 lines )\n( coqc version trunk (September 2014) compiled on Sep 20 2014 8:6:39 with OCaml 3.12.1\ncoqtop version trunk (September 2014) *)\nDefinition compose {A B C : Type} (g : B -> C) (f : A -> B) := fun x => g (f x).\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A }.\nModule Type UNIT_SUBUNIVERSE.\nParameter inO : Type -> Type.\nParameter O : Type -> Type.\nParameter O_unit : forall T, T -> O T.\nEnd UNIT_SUBUNIVERSE.\nModule Type REFLECTIVE_SUBUNIVERSE.\nDeclare Module rsubu_usubu : UNIT_SUBUNIVERSE.\nExport rsubu_usubu.\nParameter O_rectnd\n: forall {P Q : Type} {Q_inO : inO Q} (f : P -> Q), O P -> Q."
337524956,3670,2014-09-30 18:57:01,"Unfortunately, neither changing := to exact or putting all variables to the right of the colon seems to help in my original example.  Now running coq-bug-finder again..."
337543046,4780,2016-06-04 05:18:43,"( File reduced by coq-bug-finder from original input, then from 1889 lines to 144 lines, then from 158 lines to 144 lines )\n( coqc version 8.5pl1 (April 2016) compiled on Apr 18 2016 14:48:5 with OCaml 4.02.3\ncoqtop version 8.5pl1 (April 2016) *)\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := abstract case proof_admitted.\nGlobal Set Universe Polymorphism.\nGlobal Set Asymmetric Patterns.\nNotation ""'exists' x .. y , p"" := (sigT (fun x => .. (sigT (fun y => p)) ..))\n(at level 200, x binder, right associativity,\nformat ""'[' 'exists'  '/  ' x  ..  y ,  '/  ' p ']'"")\n: type_scope.\nDefinition relation (A : Type) := A -> A -> Type.\nClass Transitive {A} (R : relation A) := transitivity : forall x y z, R x y -> R y z -> R x z.\nTactic Notation ""etransitivity"" open_constr(y) :=\nlet R := match goal with |- ?R ?x ?z => constr:(R) end in"
337544300,4862,2016-06-27 20:12:10,"( File reduced by coq-bug-finder from original input, then from 1168 lines to 33 lines, then from 138 lines to 34 lines, then from 220 lines to 35 lines, then from 93 lines to 37 lines, then from 118 lines to 41 lines, then from 293 lines to 52 lines, then from 350 lines to 86 lines, then from 126 lines to 85 lines, then from 296 lines to 119 lines, then from 135 lines to 119 lines, then from 583 lines to 221 lines, then from 1441 lines to 390 lines, then from 1253 lines to 539 lines, then from 553 lines to 539 lines, then from 553 lines to 539 lines, then from 529 lines to 511 lines, then from 471 lines to 169 lines, then from 353 lines to 173 lines, then from 236 lines to 179 lines, then from 296 lines to 193 lines, then from 207 lines to 194 lines, then from 146 lines to 101 lines, then from 115 lines to 101 lines )\n( coqc version 8.5pl1 (June 2016) compiled on Jun 13 2016 21:7:27 with OCaml 4.02.3\ncoqtop version 8.5pl1 (June 2016) *)\nModule Export Notations.\nReserved Notation ""x -> y"" (at level 99, right associativity, y at level 200).\nReserved Notation ""~ x"" (at level 75, right associativity).\nReserved Notation ""x = y  :>  T""\n(at level 70, y at next level, no associativity).\nReserved Notation ""x = y"" (at level 70, no associativity).\nOpen Scope type_scope.\nDeclare ML Module ""coretactics"".\nDeclare ML Module ""extratactics"".\nEnd Notations.\nGlobal Set Universe Polymorphism.\nNotation ""A -> B"" := (forall (_ : A), B) : type_scope."
337550886,5323,2017-01-22 05:35:04,"( File reduced by coq-bug-finder from original input, then from 440 lines to\n147 lines, then from 452 lines to 178 lines, then from \n204 lines to 76 lines, then from 102 lines to 44 lines, then from 482 lines to\n129 lines, then from 223 lines to 132 lines, then from\n237 lines to 134 lines, then from 183 lines to 135 lines, then from 149 lines\nto 135 lines, then from 112 lines to 46 lines, then fr\nom 60 lines to 47 lines, then from 54 lines to 24 lines, then from 38 lines to\n25 lines )\n( coqc version 8.6rc1 (December 2016) compiled on Dec 8 2016 13:43:59 with\nOCaml 4.02.3\ncoqtop version 8.6rc1 (December 2016) *)\nInductive flat_type := Unit | Prod (A B : flat_type).\nInductive exprf (op : flat_type -> flat_type -> Type) {var : Type} : flat_type\n-> Type :=\n| Op {t1 tR} (opc : op t1 tR) (args : exprf op t1) : exprf op tR."
337541694,4679,2016-04-19 19:33:57,"( File reduced by coq-bug-finder from original input, then from 1681 lines to 1437 lines, then from 1728 lines to 1521 lines, then from 587 lines to 446 lines, then from 1198 lines to 485 lines, then from 693 lines to 561 lines, then from 810 lines to 563 lines, then from 835 lines to 651 lines, then from 796 lines to 675 lines, then from 885 lines to 719 lines, then from 980 lines to 747 lines, then from 1286 lines to 748 lines, then from 978 lines to 762 lines, then from 1139 lines to 763 lines, then from 2823 lines to 763 lines, then from 962 lines to 763 lines, then from 1103 lines to 763 lines, then from 1514 lines to 763 lines, then from 949 lines to 763 lines, then from 903 lines to 805 lines, then from 973 lines to 839 lines, then from 924 lines to 853 lines, then from 1425 lines to 984 lines, then from 1170 lines to 1074 lines, then from 1584 lines to 1103 lines, then from 1172 lines to 931 lines, then from 1027 lines to 947 lines, then from 1062 lines to 987 lines, then from 1059 lines to 990 lines, then from 1169 lines to 991 lines, then from 1347 lines to 1001 lines, then from 1228 lines to 1038 lines, then from 1100 lines to 1039 lines, then from 1400 lines to 1146 lines, then from 1541 lines to 1227 lines, then from 1604 lines to 1313 lines, then from 1407 lines to 1310 lines, then from 3164 lines to 1313 lines, then from 1383 lines to 1311 lines, then from 1356 lines to 1311 lines, then from 1687 lines to 1363 lines, then from 1709 lines to 1362 lines, then from 1843 lines to 1371 lines, then from 1735 lines to 1375 lines, then from 1456 lines to 1373 lines, then from 3213 lines to 1382 lines, then from 1439 lines to 1381 lines, then from 1412 lines to 1381 lines, then from 2916 lines to 1429 lines, then from 1505 lines to 1482 lines, then from 3314 lines to 1487 lines, then from 1501 lines to 1485 lines, then from 1562 lines to 1178 lines, then from 1192 lines to 1175 lines, then from 978 lines to 284 lines, then from 298 lines to 284 lines )\n( coqc version 8.5 (April 2016) compiled on Apr 18 2016 14:50:52 with OCaml 4.02.3\ncoqtop version 8.5 (April 2016) *)\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := case proof_admitted.\nRequire Coq.Program.Program.\nRequire Coq.Sets.Ensembles.\nExport Coq.Setoids.Setoid.\nImport Coq.Vectors.VectorDef.VectorNotations.\nSection ilist2.\nContext {A : Type}.\nContext {B : A -> Type}.\nFixpoint ilist2 {n} (l : Vector.t A n) : Type :=\nmatch l with\n| [] => unit"
337521428,3454,2014-07-24 00:17:07,"(* File reduced by coq-bug-finder from original input, then from 5135 lines to 4962 lines, then from 4444 lines to 100 lines, then from 106 lines to 97 lines, then from 105 lines to 28 lines *)\nSet Primitive Projections.\nRecord sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\nNotation pr1 := (@ projT1 _ _).\nDefinition compose {A B C : Type} (g : B -> C) (f : A -> B) := fun x => g (f x).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nClass IsEquiv {A B : Type} (f : A -> B) := {}.\nLocal Instance isequiv_tgt_compose A B\n: @ IsEquiv (A -> {xy : B * B & fst xy = snd xy})\n(A -> B)\n(@ compose A {xy : B * B & fst xy = snd xy} B (@ compose {xy : B * B & fst xy = snd xy} _ B (@ snd B B) pr1)).\n(* Toplevel input, characters 220-223:\nError: Cannot infer this placeholder. *)\nLocal Instance isequiv_tgt_compose A B"
337520876,3420,2014-07-14 14:47:43,"(* File reduced by coq-bug-finder from original input, then from 3418 lines to 82 lines )\nGeneralizable All Variables.\nSet Asymmetric Patterns.\nNotation ""( x ; y )"" := (existT _ x y) : fibration_scope.\nOpen Scope fibration_scope.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition Sect {A B : Type} (s : A -> B) (r : B -> A) := forall x : A, r (s x) = x.\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A ; eissect : Sect f equiv_inv }.\nDefinition eta_sigma {P : A -> Type} (u : sigT P) : (projT1 u; projT2 u) = u := match u with existT x y => idpath end. Definition sigT_corect_uncurried {A : X -> Type} (P : forall x, A x -> Type)\n: { f : forall x, A x & forall x, P x (f x) } -> (forall x, sigT (P x))\n:= fun fg => fun x => (projT1 fg x ; projT2 fg x).\nInstance isequiv_sigT_corect `{A : X -> Type} {P : forall x, A x -> Type} : IsEquiv (sigT_corect_uncurried P) | 0\n:= Build_IsEquiv _ _\n(sigT_corect_uncurried P)"
337520213,3374,2014-06-10 22:50:32,"(* File reduced by coq-bug-finder from original input, then from 5968 lines to 11933 lines, then from 11239 lines to 11231 lines, then from 10365 lines to 446 lines, then from 456 lines to 379 lines, then from 391 lines to 373 lines, then from 369 lines to 351 lines, then from 350 lines to 340 lines, then from 348 lines to 320 lines, then from 328 lines to 302 lines, then from 331 lines to 59 lines *)\nSet Universe Polymorphism.\nAxiom admit : forall {T}, T.\nNotation paths := identity .\nDefinition UU := Set.\nDefinition dirprod ( X Y : UU ) := sigT ( fun x : X => Y ) .\nDefinition dirprodpair { X Y : UU } := existT ( fun x : X => Y ) .\nDefinition hProp := sigT (fun X : Type => admit).\nDefinition hProptoType := @ projT1 _ _ : hProp -> Type .\nCoercion hProptoType: hProp >-> Sortclass.\nDefinition UU' := Type.\nDefinition hSet:= sigT (fun X : UU' => admit) .\nDefinition pr1hSet:= @ projT1 UU (fun X : UU' => admit) : hSet -> Type.\nCoercion pr1hSet: hSet >-> Sortclass.\nAxiom hsubtypes : UU -> Type."
337532218,4097,2015-03-02 01:27:44,"(* File reduced by coq-bug-finder from original input, then from 6082 lines to 81 lines, then from 436 lines to 93 lines )\n( coqc version 8.5beta1 (February 2015) compiled on Feb 27 2015 15:10:37 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (fc1b3ef) *)\nGlobal Set Primitive Projections.\nRecord sigT {A} (P : A -> Type) := exist { projT1 : A ; projT2 : P projT1 }.\nArguments projT1 {A P} _ / .\nArguments projT2 {A P} _ / .\nNotation ""{ x : A  & P }"" := (sigT (fun x:A => P)) : type_scope.\nDelimit Scope path_scope with path.\nDelimit Scope fibration_scope with fibration.\nOpen Scope path_scope.\nOpen Scope fibration_scope.\nNotation ""( x ; y )"" := (existT _ x y) : fibration_scope.\nNotation pr1 := projT1.\nNotation pr2 := projT2."
337529273,3922,2015-01-16 11:27:38,"(* File reduced by coq-bug-finder from original input, then from 8338 lines to 7688 lines, then from 6940 lines to 91 lines, then from 106 lines to 86 lines )\n( coqc version trunk (January 2015) compiled on Jan 16 2015 4:25:15 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (62ce6ac) *)\nSet Universe Polymorphism.\nNotation Type0 := Set.\nDefinition Type1 := Eval hnf in let gt := (Set : Type@ {i}) in Type@ {i}.\nNotation compose := (fun g f x => g (f x)).\nNotation ""g 'o' f"" := (compose g f) (at level 40, left associativity) : function_scope.\nOpen Scope function_scope.\nDefinition pointwise_paths {A} {P:A->Type} (f g:forall x:A, P x)\n:= forall x:A, f x = g x.\nNotation ""f == g"" := (pointwise_paths f g) (at level 70, no associativity) : type_scope.\nClass Contr_internal (A : Type) := BuildContr {\ncenter : A ;\ncontr : (forall y : A, center = y)"
337524843,3661,2014-09-25 07:43:47,"(* File reduced by coq-bug-finder from original input, then from 11218 lines to 438 lines, then from 434 lines to 202 lines, then from 140 lines to 94 lines )\n( coqc version trunk (September 2014) compiled on Sep 25 2014 2:53:46 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (bec7e09) )\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\nSet Implicit Arguments.\nDelimit Scope morphism_scope with morphism.\nRecord PreCategory := { object :> Type ; morphism : object -> object -> Type }.\nBind Scope category_scope with PreCategory.\nLocal Open Scope morphism_scope.\nRecord Functor (C D : PreCategory) :=\n{ object_of :> C -> D;\nmorphism_of : forall s d, morphism C s d -> morphism D (object_of s) (object_of d) }.\nSet Primitive Projections.\nClass IsIsomorphism {C : PreCategory} {s d} (m : morphism C s d) := { morphism_inverse : morphism C d s }.\nRecord NaturalTransformation C D (F G : Functor C D) := { components_of :> forall c, morphism D (F c) (G c) }."
337524804,3658,2014-09-24 01:01:34,"(* File reduced by coq-bug-finder from original input, then from 12178 lines to 457 lines, then from 500 lines to 147 lines, then from 175 lines to 56 lines )\n( coqc version trunk (September 2014) compiled on Sep 21 2014 16:34:4 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (eaf8643) *)\nAxiom transport : forall {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x), P y.\nAxiom ap : forall {A B:Type} (f:A -> B) {x y:A} (p:x = y), f x = f y.\nModule NonPrim.\nClass Contr_internal (A : Type) := { center : A ; contr : (forall y : A, center = y) }.\nArguments center A {} / .\nInductive trunc_index : Type := minus_two | trunc_S ( : trunc_index).\nNotation ""-2"" := minus_two (at level 0).\nFixpoint IsTrunc_internal (n : trunc_index) (A : Type) : Type :=\nmatch n with\n| -2 => Contr_internal A\n| trunc_S n' => forall (x y : A), IsTrunc_internal n' (x = y)\nend."
337524622,3648,2014-09-19 09:00:48,"(* File reduced by coq-bug-finder from original input, then from 8808 lines to 424 lines, then from 432 lines to 196 lines, then from\n145 lines to 82 lines )\n( coqc version trunk (September 2014) compiled on Sep 18 2014 21:0:5 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (07e4438) *)\nReserved Infix ""o"" (at level 40, left associativity).\nGlobal Set Primitive Projections.\nDelimit Scope morphism_scope with morphism.\nDelimit Scope category_scope with category.\nDelimit Scope object_scope with object.\nRecord PreCategory :=\n{ object :> Type;\nmorphism : object -> object -> Type;\nidentity : forall x, morphism x x;\ncompose : forall s d d',\n            morphism d d'"
337519470,3329,2014-05-16 13:00:48,"(* File reduced by coq-bug-finder from original input, then from 12095 lines to 869 lines, then from 792 lines to 504 lines, then from 487 lines to 353 lines, then from 258 lines to 174 lines, then from 164 lines to 132 lines, then from 129 lines to 99 lines *)\nSet Universe Polymorphism.\nGeneralizable All Variables.\nAxiom admit : forall {T}, T.\nReserved Notation ""g 'o' f"" (at level 40, left associativity).\nDefinition compose {A B C : Type} (g : B -> C) (f : A -> B) := fun x => g (f x).\nNotation ""g 'o' f"" := (compose g f).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition pointwise_paths {A} {P:A->Type} (f g:forall x:A, P x) : Type := forall x:A, f x = g x.\nHint Unfold pointwise_paths : typeclass_instances.\nDefinition apD10 {A} {B:A->Type} {f g : forall x, B x} (h:f=g)\n: forall x, f x = g x\n:= fun x => match h with idpath => idpath end.\nClass IsEquiv {A B : Type} (f : A -> B) := BuildIsEquiv { equiv_inv : B -> A }."
337526069,3734,2014-10-14 17:03:34,"( File reduced by coq-bug-finder from original input, then from 25856 lines to 19986 lines, then from 19167 lines to 15037 lines, then from 15051 lines to 14789 lines, then from 14803 lines to 12005 lines, then from 12019 lines to 12009 lines, then from 12023 lines to 924 lines, then from 918 lines to 448 lines, then from 435 lines to 364 lines, then from 261 lines to 198 lines )\n( coqc version trunk (October 2014) compiled on Oct 11 2014 1:13:41 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (d65496f) *)\nSet Universe Polymorphism.\nSet Primitive Projections.\nReserved Infix ""o"" (at level 40, left associativity).\nSet Implicit Arguments.\nDelimit Scope morphism_scope with morphism.\nDelimit Scope category_scope with category.\nDelimit Scope object_scope with object.\nRecord PreCategory :=\n{ object :> Type;\nmorphism : object -> object -> Type;\nidentity : forall x, morphism x x;\ncompose : forall s d d', morphism d d' -> morphism s d -> morphism s d' }."
337524129,3612,2014-09-11 21:16:59,"( File reduced by coq-bug-finder from original input, then from 3595 lines to 3518 lines, then from 3133 lines to 2950 lines, then from 2911 lines to 415 lines, then from 431 lines to 407 \nlines, then from 421 lines to 428 lines, then from 444 lines to 429 lines, then from 434 lines to 66 lines, then from 163 lines to 48 lines )\n( coqc version trunk (September 2014) compiled on Sep 11 2014 14:48:8 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (580b25e) )\nReserved Notation ""x -> y"" (at level 99, right associativity, y at level 200).\nReserved Notation ""x = y  :>  T"" (at level 70, y at next level, no associativity).\nReserved Notation ""x = y"" (at level 70, no associativity).\nOpen Scope type_scope.\nGlobal Set Universe Polymorphism.\nNotation ""A -> B"" := (forall (_ : A), B) : type_scope.\nGeneralizable All Variables.\nLocal Set Primitive Projections.\nRecord sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\nArguments projT1 {A P} _ / .\nArguments projT2 {A P} _ / ."
337545412,4955,2016-07-20 22:07:56,"(* File reduced by coq-bug-finder from original input, then from 8783 lines to\n169 lines, then from 183 lines to 169 lines, then from 96 lines to 55 lines,\nthen from 69 lines to 56 lines )\n( coqc version trunk (July 2016) compiled on Jul 20 2016 11:8:10 with OCaml\n4.02.3\ncoqtop version .../coq/coq-v8.6,v8.6\n(a341d13) *)\nNotation ""{ x : A | P }"" := (sigT (fun x:A => P)) : type_scope.\nNotation ""( x ; y )"" := (existT _ x y) : fibration_scope.\nOpen Scope fibration_scope.\nNotation ""p @  q"" := (eq_trans p q) (at level 20).\nNotation ""p ^"" := (eq_sym p) (at level 3).\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x)\n: P y :=\nmatch p with eq_refl => u end."
337520509,3392,2014-06-22 21:45:25,"(* File reduced by coq-bug-finder from original input, then from 12105 lines to 142 lines, then from 83 lines to 57 lines *)\nGeneralizable All Variables.\nAxiom admit : forall {T}, T.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y := match p with idpath => u end.\nNotation ""p # x"" := (transport _ p x) (right associativity, at level 65, only parsing).\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with idpath => idpath end.\nDefinition apD {A:Type} {B:A->Type} (f:forall a:A, B a) {x y:A} (p:x=y): transport _ p (f x) = f y := admit.\nDefinition Sect {A B : Type} (s : A -> B) (r : B -> A) := forall x : A, r (s x) = x.\nClass IsEquiv {A B : Type} (f : A -> B) := BuildIsEquiv {\nequiv_inv : B -> A ;\neisretr : Sect equiv_inv f;\neissect : Sect f equiv_inv;\neisadj : forall x : A, eisretr (f x) = ap f (eissect x) }."
337520511,3392,2014-08-14 10:47:05,"( File reduced by coq-bug-finder from original input, then from 12105 lines to 142 lines, then from 83 lines to 57 lines *)\nGeneralizable All Variables.\nNotation ""A -> B"" := (forall _ : A, B) (right associativity, at level 99, B at level 200).\nReserved Notation ""x = y  :>  T""\n(at level 70, y at next level, no associativity).\nReserved Notation ""x = y"" (at level 70, no associativity).\nRequire Import Coq.Init.Logic.\nAxiom admit : forall {T}, T.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y := match p with idpath => u end.\nNotation ""p # x"" := (transport _ p x) (right associativity, at level 65, only parsing).\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with idpath => idpath end.\nDefinition apD {A:Type} {B:A->Type} (f:forall a:A, B a) {x y:A} (p:x=y): transport _ p (f x) = f y := admit.\nDefinition Sect {A B : Type} (s : A -> B) (r : B -> A) := forall x : A, r (s x) = x."
337519371,3323,2014-05-14 23:22:40,"( File reduced by coq-bug-finder from original input, then from 5302 lines to 4649 lines, then from 4660 lines to 355 lines, then from 360 lines to 269 lines, then from 269 lines to 175 lines, then from 144 lines to 119 lines, then from 297 lines to 117 lines, then from 95 lines to 79 lines, then from 82 lines to 68 lines *)\nSet Universe Polymorphism.\nGeneralizable All Variables.\nInductive sigT {A:Type} (P:A -> Type) : Type := existT : forall x:A, P x -> sigT P.\nNotation ""{ x : A  & P }"" := (sigT (fun x:A => P)) : type_scope.\nDefinition projT1 {A} {P : A -> Type} (x : sigT P) : A := let (a, _) := x in a.\nDefinition projT2 {A} {P : A -> Type} (x : sigT P) : P (projT1 x) := let (a, h) return P (projT1 x) := x in h.\nAxiom admit : forall {T}, T.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x := match p with idpath => idpath end.\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y := match p with idpath => u end.\nDefinition Sect {A B : Type} (s : A -> B) (r : B -> A) := forall x : A, r (s x) = x.\nClass IsEquiv {A B : Type} (f : A -> B) := BuildIsEquiv { equiv_inv : B -> A ; eisretr : Sect equiv_inv f }.\nRecord Equiv A B := BuildEquiv { equiv_fun :> A -> B ; equiv_isequiv :> IsEquiv equiv_fun }."
337525220,3685,2014-09-30 17:13:47,"(* File reduced by coq-bug-finder from original input, then from 14001 lines to 844 lines, then from 848 lines to 524 lines, then fro\nm 525 lines to 336 lines, then from 259 lines to 186 lines, then from 98 lines to 64 lines )\n( coqc version trunk (September 2014) compiled on Sep 29 2014 14:5:39 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-HoTT,(no branch) (e872655) *)\nSet Universe Polymorphism.\nClass Funext := { }.\nDelimit Scope category_scope with category.\nRecord PreCategory := { object :> Type ; morphism : object -> object -> Type }.\nSet Implicit Arguments.\nRecord Functor (C D : PreCategory) :=\n{ object_of :> C -> D;\nmorphism_of : forall s d, morphism C s d -> morphism D (object_of s) (object_of d);\nidentity_of : forall s m, morphism_of s s m = morphism_of s s m }.\nDefinition sub_pre_cat {Funext} (P : PreCategory -> Type) : PreCategory. Proof. exact (@ Build_PreCategory PreCategory Functor). Defined. Definition opposite (C : PreCategory) : PreCategory. Proof. exact (@ Build_PreCategory C (fun s d => morphism C d s)). Defined. Local Notation ""C ^op"" := (opposite C) (at level 3, format ""C '^op'"") : category_scope. Definition prod (C D : PreCategory) : PreCategory. Proof. refine (@ Build_PreCategory (C * D)%type (fun s d => (morphism C (fst s) (fst d) * morphism D (snd s) (snd d))%type)). Defined. Local Infix ""*"" := prod : category_scope. Record NaturalTransformation C D (F G : Functor C D) := {}. Definition functor_category (C D : PreCategory) : PreCategory. Proof. exact (@ Build_PreCategory (Functor C D) (@ NaturalTransformation C D)). Defined. Local Notation ""C -> D"" := (functor_category C D) : category_scope. Module Export PointwiseCore. Local Open Scope category_scope. Definition pointwise (C C' : PreCategory) (F : Functor C' C) (D D' : PreCategory) (G : Functor D D') : Functor (C -> D) (C' -> D'). Proof. refine (Build_Functor (C -> D) (C' -> D') _ _ _); abstract admit. Defined. End PointwiseCore. Axiom Pidentity_of : forall (C D : PreCategory) (F : Functor C C) (G : Functor D D), pointwise F G = pointwise F G. Local Open Scope category_scope. Module Success. Definition functor_uncurried {Funext} (P : PreCategory -> Type)\n(has_functor_categories : forall C D : sub_pre_cat P, P (C -> D))"
337523127,3559,2014-08-31 20:20:27,"( File reduced by coq-bug-finder from original input, then from 8657 lines to 4731 lines, then from 4174 lines to 192 lines, then from 161 lines to 55 lines, then from 51 lines to 37 lines, then from 43 lines to 30 lines )\n( coqc version trunk (August 2014) compiled on Aug 31 2014 10:12:32 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (437b91a) )\nSet Universe Polymorphism.\nGeneralizable All Variables.\nDefinition iff A B := prod (A -> B) (B -> A).\nInfix ""<->"" := iff : type_scope.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nClass Contr_internal (A : Type) := { center : A ; contr : (forall y : A, center = y) }.\nInductive trunc_index : Type := minus_two | trunc_S (_ : trunc_index).\nFixpoint IsTrunc_internal (n : trunc_index) (A : Type) : Type :=\nmatch n with\n| minus_two => Contr_internal A\n| trunc_S n' => forall (x y : A), IsTrunc_internal n' (x = y)\nend."
337523131,3559,2014-09-02 04:37:05,"( File reduced by coq-bug-finder from original input, then from 8657 lines to 4731 lines, then from 4174 lines to 192 lines, then from 161 lines to 55 lines, then from 51 lines to 37 lines, then from 43 lines to 30 lines )\n( coqc version trunk (August 2014) compiled on Aug 31 2014 10:12:32 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (437b91a) *)\nRequire Import Coq.Init.Notations.\nSet Universe Polymorphism.\nGeneralizable All Variables.\nRecord prod A B := pair { fst : A ; snd : B }.\nArguments pair {_ _} _ .\nReserved Notation ""x -> y"" (at level 99, right associativity, y at level 200).\nReserved Notation ""x <-> y"" (at level 95, no associativity).\nReserved Notation ""x = y"" (at level 70, no associativity).\nNotation ""A -> B"" := (forall ( : A), B) : type_scope.\nOpen Scope type_scope.\nDefinition iff A B := prod (A -> B) (B -> A).\nInfix ""<->"" := iff : type_scope."
337521912,3480,2014-08-01 20:34:54,"(* File reduced by coq-bug-finder from original input, then from 7268 lines to 5182 lines, then from 4588 lines to 4440 lines, then from 4451 lines to 293 lines, then from 206 lines to 90 lines, then from 72 lines to 48 lines *)\nAxiom admit : forall {T}, T.\nNotation ""( x ; y )"" := (existT _ x y) : fibration_scope.\nOpen Scope fibration_scope.\nNotation ""x .1"" := (projT1 x) (at level 3) : fibration_scope.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nSet Implicit Arguments.\nDelimit Scope category_scope with category.\nRecord PreCategory := { object :> Type ; morphism : object -> object -> Type }.\nLocal Open Scope category_scope.\nClass IsIsomorphism {C : PreCategory} {s d} (m : morphism C s d) := { morphism_inverse : morphism C d s }.\nClass Isomorphic {C : PreCategory} s d := { morphism_isomorphic :> @ morphism C s d ; isisomorphism_isomorphic :> IsIsomorphism morphism_isomorphic }.\nCoercion morphism_isomorphic : Isomorphic >-> morphism.\nLocal Infix ""<=>"" := Isomorphic (at level 70, no associativity) : category_scope.\nDefinition idtoiso (C : PreCategory) (x y : C) (H : x = y) : Isomorphic x y := admit."
337523681,3588,2014-09-06 22:21:59,"(* File reduced by coq-bug-finder from original input, then from 6764 lines to 263 lines, then from 263 lines to 115 lines, then from 90 lines to 71 lines )\n( coqc version trunk (September 2014) compiled on Sep 6 2014 6:15:6 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (3ea6d68) *)\nGeneralizable All Variables.\nDefinition compose {A B C : Type} (g : B -> C) (f : A -> B) := fun x => g (f x).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\nArguments idpath {A a} , [A] a.\nNotation ""x = y :> A"" := (@ paths A x y) : type_scope.\nNotation ""x = y"" := (x = y :>) : type_scope.\nDelimit Scope path_scope with path.\nLocal Open Scope path_scope.\nDefinition concat {A : Type} {x y z : A} (p : x = y) (q : y = z) : x = z := match p, q with idpath, idpath => idpath end.\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x := match p with idpath => idpath end.\nNotation ""1"" := idpath : path_scope.\nNotation ""p @  q"" := (concat p q) (at level 20) : path_scope."
337539480,4533,2016-01-26 09:16:06,"( File reduced by coq-bug-finder from original input, then from 1125 lines to\n346 lines, then from 360 lines to 346 lines, then from 822 lines to 271 lines,\nthen from 285 lines to 271 lines )\n( coqc version 8.5 (January 2016) compiled on Jan 23 2016 16:15:22 with OCaml\n4.01.0\ncoqtop version 8.5 (January 2016) *)\nInductive False := .\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := case proof_admitted.\nRequire Coq.Init.Datatypes.\nImport Coq.Init.Notations.\nGlobal Set Universe Polymorphism.\nNotation ""A -> B"" := (forall (_ : A), B) : type_scope.\nModule Export Datatypes.\nSet Implicit Arguments."
337539481,4533,2016-01-29 20:52:33,"( File reduced by coq-bug-finder from original input, then from 1125 lines to  346 lines, then from 360 lines to 346 lines, then from 822 lines to 271 lines,  then from 285 lines to 271 lines )\n( coqc version 8.5 (January 2016) compiled on Jan 23 2016 16:15:22 with OCaml  4.01.0\ncoqtop version 8.5 (January 2016) *)\nInductive False := .\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := case proof_admitted.\nRequire Coq.Init.Datatypes.\nImport Coq.Init.Notations.\nGlobal Set Universe Polymorphism.\nGlobal Set Primitive Projections.\nNotation ""A -> B"" := (forall (_ : A), B) : type_scope.\nModule Export Datatypes.\nSet Implicit Arguments.\nNotation nat := Coq.Init.Datatypes.nat.\nNotation S := Coq.Init.Datatypes.S."
337528076,3854,2014-12-12 07:08:31,"(* File reduced by coq-bug-finder from original input, then from 15831 lines to 7052 lines, then from 6868 lines to 199 lines, then from 204 lines to 66 lines )\n( coqc version trunk (December 2014) compiled on Dec 10 2014 12:26:15 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (c938cb8) *)\nDefinition relation (A : Type) := A -> A -> Type.\nClass Reflexive {A} (R : relation A) := reflexivity : forall x : A, R x x.\nAxiom IsHProp : Type -> Type.\nExisting Class IsHProp.\nInductive Empty : Set := .\nNotation ""~ x"" := (x -> Empty) : type_scope.\nRecord hProp := BuildhProp { type :> Type ; trunc : IsHProp type }.\nArguments BuildhProp _ {_}.\nCanonical Structure default_hProp := fun T P => (@ BuildhProp T P).\nGeneralizable Variables A B f g e n.\nAxiom trunc_forall : forall `{P : A -> Type}, IsHProp (forall a, P a).\nExisting Instance trunc_forall."
337526184,3742,2014-10-15 06:06:41,"(* File reduced by coq-bug-finder from original input, then from 287 lines to 208 lines )\n( coqc version trunk (October 2014) compiled on Oct 11 2014 1:13:41 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (d65496f) *)\nRequire Coq.Sorting.Permutation.\nExport Coq.Sorting.Permutation.\nDefinition BagInsertEnumerate\n{TContainer TItem: Type}\n(RepInv : TContainer -> Prop)\n(benumerate : TContainer -> list TItem)\n(binsert    : TContainer -> TItem -> TContainer) :=\nforall inserted container\n(containerCorrect : RepInv container),\nPermutation\n(benumerate (binsert container inserted))\n(inserted :: benumerate container)."
337521250,3447,2014-07-21 10:06:08,"( File reduced by coq-bug-finder from original input, then from 7372 lines to 539 lines, then from 532 lines to 505 lines *)\nGeneralizable All Variables.\nSet Asymmetric Patterns.\nSet Universe Polymorphism.\nAxiom admit : forall {T}, T.\nArguments projT1 {_ _} .\nDefinition relation (A : Type) := A -> A -> Type.\nClass Reflexive {A} (R : relation A) := reflexivity : forall x : A, R x x.\nClass Symmetric {A} (R : relation A) := symmetry : forall x y, R x y -> R y x.\nNotation ""( x ; y )"" := (existT _ x y) : fibration_scope.\nOpen Scope fibration_scope.\nNotation pr1 := projT1.\nNotation ""x .1"" := (projT1 x) (at level 3) : fibration_scope.\nNotation ""x .2"" := (projT2 x) (at level 3) : fibration_scope.\nDefinition compose' {A B C : Type} (g : B -> C) (f : A -> B) := fun x => g (f x)."
337520382,3382,2014-06-17 10:52:45,"(* File reduced by coq-bug-finder from 9039 lines to 7786 lines, then from 7245 lines to 476 lines, then from 417 lines to 249 lines, then from 171 lines to 127 lines, then from 139 lines to 114 lines, then from 93 lines to 77 lines *)\nSet Implicit Arguments.\nDefinition admit {T} : T.\nAdmitted.\nDelimit Scope object_scope with object.\nDelimit Scope morphism_scope with morphism.\nDelimit Scope category_scope with category.\nDelimit Scope functor_scope with functor.\nReserved Infix ""o"" (at level 40, left associativity).\nRecord PreCategory :=\n{ Object :> Type;\nMorphism : Object -> Object -> Type;\nCompose : forall s d d', Morphism d d' -> Morphism s d -> Morphism s d' where ""f 'o' g"" := (Compose f g) }.\nBind Scope category_scope with PreCategory.\nInfix ""o"" := (@ Compose _ _ _ _) : morphism_scope."
337522304,3504,2014-08-10 13:00:49,"(* File reduced by coq-bug-finder from original input, then from 15037 lines to 13721 lines, then from 13307 lines to 556 lines, then from 556 lines to 176 lines, then from 134 lines to 37 lines )\nSet Implicit Arguments.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nUnset Printing Notations.\nModule NonPrim.\nUnset Primitive Projections.\nRecord PreCategory := { object :> Type ; morphism : object -> object -> Type ; identity : forall x, morphism x x }.\nRecord Functor (C D : PreCategory) :=\n{ object_of :> C -> D;\nmorphism_of : forall s d, morphism C s d -> morphism D (object_of s) (object_of d);\nidentity_of : forall x, morphism_of _ _ (identity _ x) = identity _ (object_of x) }.\nDefinition indiscrete_category X : PreCategory := @ Build_PreCategory X (fun _ _ => unit) (fun _ => tt).\nGoal forall (C : PreCategory) (X : Functor (indiscrete_category unit) C),\n@ paths (morphism C (object_of X tt) (object_of X tt))\n(morphism_of X tt tt tt)"
337523292,3567,2014-09-02 07:27:52,"(* File reduced by coq-bug-finder from original input, then from 2901 lines to 69 lines, then from 80 lines to 63 lines )\n( coqc version trunk (September 2014) compiled on Sep 2 2014 2:7:1 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (3c5daf4) *)\nSet Primitive Projections.\nSet Implicit Arguments.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nArguments fst {A B} _ / .\nArguments snd {A B} _ / .\nAdd Printing Let prod.\nNotation ""x * y"" := (prod x y) : type_scope.\nNotation ""( x , y , .. , z )"" := (pair .. (pair x y) .. z) : core_scope.\nUnset Implicit Arguments.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with idpath => idpath end."
337523295,3567,2014-09-02 07:56:46,"(* File reduced by coq-bug-finder from original input, then from 2901 lines to 69 lines, then from 80 lines to 63 lines )\n( coqc version trunk (September 2014) compiled on Sep 2 2014 2:7:1 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (3c5daf4) *)\nSet Primitive Projections.\nSet Implicit Arguments.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nArguments fst {A B} _ / .\nArguments snd {A B} _ / .\nAdd Printing Let prod.\nReserved Notation ""x * y"" (at level 40, left associativity).\nNotation ""x * y"" := (prod x y) : type_scope.\nNotation ""( x , y , .. , z )"" := (pair .. (pair x y) .. z) : core_scope.\nUnset Implicit Arguments.\nReserved Notation ""x -> y"" (at level 99, right associativity, y at level 200).\nReserved Notation ""x = y"" (at level 70, no associativity)."
337520980,3427,2014-07-16 08:30:55,"( File reduced by coq-bug-finder from original input, then from 0 lines to 7171 lines, then from 7184 lines to 558 lines, then from 556 lines to 209 lines *)\nGeneralizable All Variables.\nSet Universe Polymorphism.\nNotation Type0 := Set.\nNotation idmap := (fun x => x).\nDefinition compose {A B C : Type} (g : B -> C) (f : A -> B) := fun x => g (f x).\nNotation ""g 'o' f"" := (compose g f) (at level 40, left associativity) : function_scope.\nOpen Scope function_scope.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDelimit Scope path_scope with path.\nLocal Open Scope path_scope.\nDefinition concat {A : Type} {x y z : A} (p : x = y) (q : y = z) : x = z := match p, q with idpath, idpath => idpath end.\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x := match p with idpath => idpath end.\nNotation ""1"" := idpath : path_scope."
337526763,3772,2014-10-27 06:10:19,"(* File reduced by coq-bug-finder from original input, then from 9012 lines to 366 lines, then from 378 lines to 163 lines, then from\n143 lines to 96 lines, then from 70 lines to 33 lines )\n( coqc version trunk (October 2014) compiled on Oct 25 2014 19:2:39 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (0397aa5) *)\nDefinition compose {A B C : Type} (g : B -> C) (f : A -> B) := fun x => g (f x).\nNotation ""g 'o' f"" := (compose g f) (at level 40, left associativity).\nClass Foo := Build_Foo : Set.\nModule MoreProgress.\nDefinition path_universe {A B : Type} (f : A -> B) {feq : Foo} : (A = B).\nadmit.\nDefined.\nGoal forall (H : Foo) (H0 H1 : Type) (H2 : H1 -> H0)\n(H3 : Type) (H4 : H1 -> H3) (H5 : H1 = H3 -> H3 -> H1)\n(H7 : (H3 -> H0) -> H3 -> Type) (H9 : H3) (H12 : Type),\n(forall (k : H1 = H3) (x : H3), H7 (H2 o H5 k) x = H12) ->"
337532167,4094,2015-02-26 00:52:04,"(* File reduced by coq-bug-finder from original input, then from 3302 lines to 2916 lines, then from 2498 lines to 2486 lines, then from 2502 lines to 220 lines, then from 235 lines to 221 lines )\n( coqc version 8.5beta1 (February 2015) compiled on Feb 23 2015 18:32:3 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (ebfc19d) *)\nOpen Scope type_scope.\nDefinition relation (A : Type) := A -> A -> Type.\nClass Transitive {A} (R : relation A) :=\ntransitivity : forall x y z, R x y -> R y z -> R x z.\nTactic Notation ""etransitivity"" open_constr(y) :=\nlet R := match goal with |- ?R ?x ?z => constr:(R) end in\nlet x := match goal with |- ?R ?x ?z => constr:(x) end in\nlet z := match goal with |- ?R ?x ?z => constr:(z) end in\nlet pre_proof_term_head := constr:(@ transitivity _ R _) in\nlet proof_term_head := (eval cbn in pre_proof_term_head) in\nrefine (proof_term_head x y z _ _); [ change (R x y) | change (R y z) ].\nLtac transitivity x := etransitivity x."
337526976,3785,2014-10-30 02:41:24,"(* File reduced by coq-bug-finder from original input, then from 9765 lines to 178 lines, then from 145 lines to 102 lines, then from 99 lines to 64 lines )\n( coqc version trunk (October 2014) compiled on Oct 28 2014 14:33:38 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,(no branch) (53bfe9c) )\nNotation ""( x ; y )"" := (existT _ x y).\nNotation pr1 := projT1.\nDefinition compose {A B C : Type} (g : B -> C) (f : A -> B) := fun x => g (f x).\nNotation ""g 'o' f"" := (compose g f) (at level 40, left associativity) : function_scope.\nOpen Scope function_scope.\nDefinition pointwise_paths {A} {P:A->Type} (f g:forall x:A, P x) := forall x:A, f x = g x.\nNotation ""f == g"" := (pointwise_paths f g) (at level 70, no associativity) : type_scope.\nDefinition hfiber {A B : Type} (f : A -> B) (y : B) := { x : A & f x = y }.\nRecord UnitSubuniverse :=\n{ inO_internal : Type -> Type ;\nO_reflector : Type -> Type ;\nto : forall T, T -> O_reflector T }."
337522331,3506,2014-08-10 17:40:44,"(* File reduced by coq-bug-finder from original input, then from 6694 lines to 5554 lines, then from 5074 lines to 4062 lines, then from 4053 lines to 283 lines, then from 270 lines to 195 lines, then from 132 lines to 66 lines, then from 64 lines to 52 lines )\nSet Implicit Arguments.\nGeneralizable All Variables.\nDefinition compose {A B C : Type} (g : B -> C) (f : A -> B) := fun x => g (f x).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDelimit Scope path_scope with path.\nLocal Open Scope path_scope.\nDefinition concat {A : Type} {x y z : A} (p : x = y) (q : y = z) : x = z :=\nmatch p, q with idpath, idpath => idpath end.\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x\n:= match p with idpath => idpath end.\nNotation ""p @  q"" := (concat p q) (at level 20) : path_scope.\nNotation ""p ^"" := (inverse p) (at level 3) : path_scope.\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y :="
337520525,3393,2014-06-22 22:08:29,"( File reduced by coq-bug-finder from original input, then from 8760 lines to 7519 lines, then from 7050 lines to 909 lines, then from 846 lines to 578 lines, then from 497 lines to 392 lines, then from 365 lines to 322 lines, then from 252 lines to 205 lines, then from 215 lines to 204 lines, then from 210 lines to 182 lines, then from 175 lines to 157 lines *)\nSet Universe Polymorphism.\nAxiom admit : forall {T}, T.\nSet Implicit Arguments.\nGeneralizable All Variables.\nReserved Notation ""g 'o' f"" (at level 40, left associativity).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""a = b"" := (@ paths _ a b) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition apD10 {A} {B:A->Type} {f g : forall x, B x} (h:f=g) : forall x, f x = g x := fun x => match h with idpath => idpath end.\nClass IsEquiv {A B : Type} (f : A -> B) := BuildIsEquiv { equiv_inv : B -> A }.\nDelimit Scope equiv_scope with equiv.\nLocal Open Scope equiv_scope.\nNotation ""f ^-1"" := (@ equiv_inv _ _ f _) (at level 3) : equiv_scope.\nClass Funext := { isequiv_apD10 :> forall (A : Type) (P : A -> Type) f g, IsEquiv (@ apD10 A P f g) }.\nDefinition path_forall {Funext} {A : Type} {P : A -> Type} (f g : forall x : A, P x) : (forall x, f x = g x) -> f = g := (@ apD10 A P\ f g)^-1. Record PreCategory := { object :> Type; morphism : object -> object -> Type; compose : forall s d d', morphism d d' -> morphism s d -> morphism s d' where ""f 'o' g"" := (compose f g); associativity : forall x1 x2 x3 x4 (m1 : morphism x1 x2) (m2 : morphism x2 x3) (m3 : morphism x3 x4), (m3 o m2) o m1 = m3 o (m2 o\ m1) }. Bind Scope category_scope with PreCategory. Bind Scope morphism_scope with morphism. Infix ""o"" := (@ compose _ _ _ _) : morphism_scope. Delimit Scope functor_scope with functor. Record Functor (C D : PreCategory) := { object_of :> C -> D; morphism_of : forall s d, morphism C s d -> morphism D (object_of s) (object_of d) }. Bind Scope functor_scope with Functor. Notation ""F '_1' m"" := (@ morphism_of _ _ F _ _ m) (at level 10, no associativity) : morphism_scope. Class IsIsomorphism {C : PreCategory} {s d} (m : morphism C s d) := { morphism_inverse : morphism C d s }. Local Notation ""m ^-1"" := (morphism_inverse (m := m)) : morphism_scope. Class Isomorphic {C : PreCategory} s d := { morphism_isomorphic :> morphism C s d; isisomorphism_isomorphic :> IsIsomorphism morphism_isomorphic }. Coercion morphism_isomorphic : Isomorphic >-> morphism. Definition isisomorphism_inverse (@ IsIsomorphism C x y m) : IsIsomorphism m^-1 := {| morphism_inverse := m |}."
337544259,4858,2016-06-25 00:09:41,"( File reduced by coq-bug-finder from original input, then from 375 lines to 15 lines, then from 128 lines to 19 lines, then from 759 lines to 236 lines, then from 253 lines to 236 lines, then from 412 lines to 351 lines, then from 356 lines to 329 lines, then from 343 lines to 329 lines, then from 324 lines to 264 lines, then from 278 lines to 264 lines )\n( coqc version 8.5pl1 (June 2016) compiled on Jun 21 2016 11:33:29 with OCaml 4.01.0\ncoqtop version 8.5pl1 (June 2016) *)\nAxiom proof_admitted : False.\nTactic Notation ""admit"" := abstract case proof_admitted.\nRequire Coq.nsatz.Nsatz.\nImport Coq.Lists.List.\nLemma cring_sub_diag_iff {R zero eq sub} `{cring:Cring.Cring (R:=R) (ring0:=zero) (ring_eq:=eq) (sub:=sub)}\n: forall x y, eq (sub x y) zero <-> eq x y.\nadmit.\nDefined.\nLtac get_goal := lazymatch goal with |- ?g => g end.\nLtac nsatz_equation_implications_to_list eq zero g :=\nlazymatch g with\n| eq ?p zero => constr:(p::nil)"
337520899,3422,2014-07-15 10:06:10,"(* File reduced by coq-bug-finder from original input, then from 8731 lines to 7930 lines, then from 7305 lines to 766 lines, then from 642 lines to 352 lines, then from 294 lines to 234 lines, then from 245 lines to 218 lines *)\nGeneralizable All Variables.\nSet Implicit Arguments.\nSet Universe Polymorphism.\nAxiom admit : forall {T}, T.\nReserved Infix ""o"" (at level 40, left associativity).\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A }.\nRecord Equiv A B := { equiv_fun :> A -> B ; equiv_isequiv :> IsEquiv equiv_fun }.\nExisting Instance equiv_isequiv.\nDelimit Scope equiv_scope with equiv.\nLocal Open Scope equiv_scope.\nNotation ""A <~> B"" := (Equiv A B) (at level 85) : equiv_scope.\nNotation ""f ^-1"" := (@ equiv_inv _ _ f _) (at level 3) : equiv_scope.\nAxiom IsHSet : Type -> Type.\nExisting Class IsHSet."
337532039,4089,2015-02-24 03:48:01,"( File reduced by coq-bug-finder from original input, then from 6522 lines to 318 lines, then from 1139 lines to 361 lines )\n( coqc version 8.5beta1 (February 2015) compiled on Feb 23 2015 18:32:3 with OCaml 4.01.0\ncoqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (ebfc19d) *)\nOpen Scope type_scope.\nGlobal Set Universe Polymorphism.\nModule Export Datatypes.\nSet Implicit Arguments.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nNotation ""x * y"" := (prod x y) : type_scope.\nNotation ""( x , y , .. , z )"" := (pair .. (pair x y) .. z) : core_scope.\nEnd Datatypes.\nModule Export Specif.\nSet Implicit Arguments.\nRecord sig {A} (P : A -> Type) := exist { proj1_sig : A ; proj2_sig : P proj1_sig }.\nNotation sigT := sig (only parsing)."
337522838,3540,2014-08-24 21:06:46,"(* File reduced by coq-bug-finder from original input, then from 11678 lines to 11330 lines, then from 10721 lines to 9544 lines, then from 9549 lines to 794 lines, then from 810 lines to 785 lines, then from 810 lines to 724 lines, then from 592 lines to 362 lines, then from 327 lines to 255 lines, then from 254 lines to 243 lines )\n( coqc version trunk (August 2014) compiled on Aug 22 2014 4:17:28 with OCaml 4.01.0\ncoqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (a67cc69) *)\nSet Implicit Arguments.\nLocal Set Primitive Projections.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nNotation ""x * y"" := (prod x y) : type_scope.\nNotation ""( x , y , .. , z )"" := (pair .. (pair x y) .. z) : core_scope.\nDefinition Type1 := Eval hnf in let U := Type in let gt := (Set : U) in U.\nReserved Infix ""o"" (at level 40, left associativity).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where ""x = y"" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDelimit Scope path_scope with path.\nLocal Open Scope path_scope.\nNotation ""1"" := idpath : path_scope."
337525616,3712,2014-10-10 03:26:28,"(* File reduced by coq-bug-finder from original input, then from 13477 lines to 1457 lines, then from 1553 lines to 1586 lines, then from 1577 lines to 1520 lines, then from 1533 lines to 879 lines, then from 883 lines to 580 lines, then from 567 lines to 398 lines, then from 392 lines to 377 lines, then from 389 lines to 377 lines, then from 378 lines to 363 lines )\n( coqc version trunk (October 2014) compiled on Oct 8 2014 13:38:17 with OCaml 4.01.0\ncoqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (335cf28) *)\nSet Universe Polymorphism.\nSet Primitive Projections.\nSet Implicit Arguments.\nRecord sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\nNotation ""{ x : A & P }"" := (sigT (fun x:A => P)) : type_scope.\nDefinition relation (A : Type) := A -> A -> Type.\nClass Reflexive {A} (R : relation A) := reflexivity : forall x : A, R x x.\nClass Symmetric {A} (R : relation A) := symmetry : forall x y, R x y -> R y x.\nNotation idmap := (fun x => x).\nNotation ""x .1"" := (projT1 x) (at level 3, format ""x '.1'"").\nReserved Infix ""o"" (at level 40, left associativity).\nGlobal Instance symmetric_paths {A} : Symmetric (@ eq A) | 0."
